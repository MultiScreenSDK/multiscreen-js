{"version":3,"sources":["msf:///msf-2.0.21.min.js?","msf:///webpack/bootstrap 48521ae112f76c1a9608?","msf:///./index.js?","msf:///./lib/msf.js?","msf:///./lib/EventEmitter.js?","msf:///./lib/Service.js?","msf:///./lib/Search.js?","msf:///./lib/util/index.js?","msf:///./lib/Application.js?","msf:///./lib/Channel.js?","msf:///./lib/util/logger.js?","msf:///./lib/util/url.js?","msf:///./lib/util/inherits.js?","msf:///./lib/util/props.js?","msf:///./lib/util/types.js?","msf:///./lib/util/querystring.js?","msf:///./lib/Client.js?","msf:///./lib/ClientList.js?"],"names":["msf","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","version","undefined","util","Service","Search","search","logger","callback","once","services","setTimeout","start","local","getLocal","remote","uri","getByURI","EventEmitter","this","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","prototype","_disabledEvents","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","emit","type","er","handler","len","args","i","listeners","error","length","arguments","Error","Array","apply","slice","r","addListener","listener","newListener","push","warned","console","trace","on","g","removeListener","fired","list","position","splice","off","removeAllListeners","key","ret","disableEvent","enableEvent","listenerCount","emitter","description","name","device","props","readOnly","Application","Channel","application","channelUri","channel","oReq","XMLHttpRequest","timeout","ontimeout","onload","status","result","JSON","parse","responseText","e","open","send","super_","discoveryFrame","STATUS_STOPPED","self","frame","document","createElement","setAttribute","style","display","src","body","appendChild","windowMessageListener","event","source","contentWindow","data","onSearchReady","results","onSearchResult","onSearchError","window","addEventListener","inherits","STATUS_STARTED","postMessage","method","onSearchStart","warn","stop","onSearchStop","url","types","queryString","service","channelURI","isString","match","TYPE_WEB_APP","TYPE_APP","client","isHost","disconnect","bind","connect","attributes","err","connected","readyHandler","debug","exitOnRemote","clients","stopCallback","invoke","install","req","code","statusText","setRequestHeader","stringify","oServiceUrl","clientId","connection","resultHandlers","connectionUrl","host","pathname","pingTimeout","pingInterval","ClientList","Object","defineProperty","get","set","isConnected","startHealthCheck","stopHealthCheck","Client","EVENT_HEALTH_CHECK","connectCallback","u","onopen","onerror","onclose","onmessage","WebSocket","binaryType","_onSocketOpen","_onSocketError","_onSocketClose","_onSocketMessage","close","publish","message","target","payload","silly","isArray","to","packMessage","oMsg","msg","msgByteLength","Blob","size","hBuff","ArrayBuffer","hView","DataView","setUint16","unpackMessage","buffer","json","view","msgByteLen","getUint16","String","fromCharCode","getUint8","params","isNotification","Date","now","_onConnect","forEach","clientInfo","me","_onDisconnect","clear","_onClientConnect","_onClientDisconnect","getById","remove","_onReady","_onUserEvent","from","unpacked","lastReceivedPing","sent","checkAndPing","setInterval","clearInterval","createLevel","level","unshift","log","levels","indexOf","toUpperCase","isValid","pattern","oUrl","parser","href","protocol","hostname","port","hash","create","ctor","superCtor","constructor","value","enumerable","writable","configurable","TempCtor","createDescriptor","w","v","obj","k","private","isNull","isBoolean","str","trim","replace","split","reduce","param","parts","val","decodeURIComponent","hasOwnProperty","keys","map","val2","encodeURIComponent","join","connectTime","freeze","item"],"mappings":"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","file":"msf-2.0.21.min.js","sourcesContent":["var msf =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\r\n\t\r\n\tvar msf = __webpack_require__(1);\r\n\t\r\n\tmsf.version = '{{version}}';\r\n\t\r\n\tif (true) {\r\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return msf; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else if (typeof module !== 'undefined' && module.exports) {\r\n\t    module.exports = msf;\r\n\t} else {\r\n\t    window.msf = msf;\r\n\t}\r\n\t\r\n\tmodule.exports = msf;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar EventEmitter = __webpack_require__(2);\r\n\tvar Service = __webpack_require__(3);\r\n\tvar Search = __webpack_require__(4);\r\n\t\r\n\t// We will use a singleton for search so that we don't create multiple frames in the page\r\n\tvar search = null;\r\n\t\r\n\t\r\n\t/**\r\n\t * The 'msf' module/object is the entry point for the API.\r\n\t * If including the library via script tag it will be a global object attached to the window\r\n\t * or the export of the module if using amd/commonjs (requirejs/browserify)\r\n\t *\r\n\t * @module msf\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t/*\r\n\t Can be used to debug if there is an issue\r\n\t msf.logger.level = 'error'|'warn'|'info'|'verbose'|'debug'|'silly'\r\n\t */\r\n\tmodule.exports.logger  = util.logger;\r\n\t\r\n\t\r\n\t/**\r\n\t * Searches the local network for compatible multiscreen services\r\n\t *\r\n\t * @param {Function} [callback] If a callback is passed the search is immediately started.\r\n\t * @param {Error} callback.err The callback handler\r\n\t * @param {Service[]} callback.result An array of {@link Service} instances found on the network\r\n\t * @returns {Search} A search instance (a singleton is used to reduce page resources)\r\n\t *\r\n\t * @example\r\n\t * msf.search(function(err, services){\r\n\t *   if(err) return console.error('something went wrong', err.message);\r\n\t *   console.log('found '+services.length+' services');\r\n\t * }\r\n\t *\r\n\t * // OR\r\n\t *\r\n\t * var search = msf.search();\r\n\t * search.on('found', function(service){\r\n\t *    console.log('found service '+service.name);\r\n\t * }\r\n\t * search.start();\r\n\t *\r\n\t */\r\n\tmodule.exports.search = function(callback){\r\n\t\r\n\t    // Create the single instance if we don't already have one\r\n\t    if(!search) search = new Search();\r\n\t\r\n\t    // If there is a callback defined, listen once for results and start the search\r\n\t    if(callback) {\r\n\t        search.once('found',function(services){\r\n\t            callback(null, services);\r\n\t        });\r\n\t\r\n\t        // start on next tick to support search callbacks and events\r\n\t        setTimeout(function(){ search.start(); },0);\r\n\t\r\n\t    }\r\n\t\r\n\t    return search;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Retrieves a reference to the service running on the current device. This is typically only used on the 'host' device.\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Error} callback.error\r\n\t * @param {Service} callback.service The service instance\r\n\t *\r\n\t * @example\r\n\t * msf.local(function(err, service){\r\n\t *   console.log('my service name is '+service.name);\r\n\t * }\r\n\t */\r\n\tmodule.exports.local = function(callback){\r\n\t\r\n\t    Service.getLocal(callback);\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Retrieves a service instance by it's uri\r\n\t *\r\n\t * @param {String} uri The uri of the service (http://host:port/api/v2/)\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Error} callback.error\r\n\t * @param {Service} callback.service The service instance\r\n\t *\r\n\t * @example\r\n\t * msf.remote('http://host:port/api/v2/',function(err, service){\r\n\t *   console.log('the service name is '+service.name);\r\n\t * }\r\n\t */\r\n\tmodule.exports.remote = function(uri, callback){\r\n\t\r\n\t    Service.getByURI(uri, callback);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* jshint newcap: false, -W040: false, -W004: false, -W003 : false */\r\n\t\"use strict\";\r\n\t\r\n\t// Copyright Joyent, Inc. and other Node contributors.\r\n\t//\r\n\t// Permission is hereby granted, free of charge, to any person obtaining a\r\n\t// copy of this software and associated documentation files (the\r\n\t// \"Software\"), to deal in the Software without restriction, including\r\n\t// without limitation the rights to use, copy, modify, merge, publish,\r\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n\t// persons to whom the Software is furnished to do so, subject to the\r\n\t// following conditions:\r\n\t//\r\n\t// The above copyright notice and this permission notice shall be included\r\n\t// in all copies or substantial portions of the Software.\r\n\t//\r\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\t\r\n\t\r\n\t/**\r\n\t * All objects which emit events are instances of EventEmitter.\r\n\t * The EventEmitter class is derived from the nodejs EventEmitter.\r\n\t *\r\n\t * For simplicity only the most used members are documented here, for full documentation read {@link http://nodejs.org/api/events.html}\r\n\t * @class EventEmitter\r\n\t * @hide-constructor\r\n\t */\r\n\tfunction EventEmitter() {\r\n\t this._events = this._events || {};\r\n\t this._maxListeners = this._maxListeners || undefined;\r\n\t}\r\n\tmodule.exports = EventEmitter;\r\n\t\r\n\t// Backwards-compat with node 0.10.x\r\n\tEventEmitter.EventEmitter = EventEmitter;\r\n\t\r\n\tEventEmitter.prototype._disabledEvents = {};\r\n\tEventEmitter.prototype._events = undefined;\r\n\tEventEmitter.prototype._maxListeners = undefined;\r\n\t\r\n\t// By default EventEmitters will print a warning if more than 10 listeners are\r\n\t// added to it. This is a useful default which helps finding memory leaks.\r\n\tEventEmitter.defaultMaxListeners = 10;\r\n\t\r\n\t// Obviously not all Emitters should be limited to 10. This function allows\r\n\t// that to be increased. Set to zero for unlimited.\r\n\tEventEmitter.prototype.setMaxListeners = function(n) {\r\n\t if (!isNumber(n) || n < 0 || isNaN(n))\r\n\t  throw TypeError('n must be a positive number');\r\n\t this._maxListeners = n;\r\n\t return this;\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.emit = function(type) {\r\n\t var er, handler, len, args, i, listeners;\r\n\t\r\n\t if (!this._events){\r\n\t     this._events = {};\r\n\t }\r\n\t\r\n\t if(this._disabledEvents[type]) return false;\r\n\t\r\n\t // If there is no 'error' event listener then throw.\r\n\t if (type === 'error') {\r\n\t  if (!this._events.error ||\r\n\t      (isObject(this._events.error) && !this._events.error.length)) {\r\n\t   er = arguments[1];\r\n\t   if (er instanceof Error) {\r\n\t    throw er; // Unhandled 'error' event\r\n\t   }\r\n\t   throw TypeError('Uncaught, unspecified \"error\" event.');\r\n\t  }\r\n\t }\r\n\t\r\n\t handler = this._events[type];\r\n\t\r\n\t if (isUndefined(handler))\r\n\t  return false;\r\n\t\r\n\t if (isFunction(handler)) {\r\n\t  switch (arguments.length) {\r\n\t   // fast cases\r\n\t   case 1:\r\n\t    handler.call(this);\r\n\t    break;\r\n\t   case 2:\r\n\t    handler.call(this, arguments[1]);\r\n\t    break;\r\n\t   case 3:\r\n\t    handler.call(this, arguments[1], arguments[2]);\r\n\t    break;\r\n\t   // slower\r\n\t   default:\r\n\t    len = arguments.length;\r\n\t    args = new Array(len - 1);\r\n\t    for (i = 1; i < len; i++)\r\n\t     args[i - 1] = arguments[i];\r\n\t    handler.apply(this, args);\r\n\t  }\r\n\t } else if (isObject(handler)) {\r\n\t  len = arguments.length;\r\n\t  args = new Array(len - 1);\r\n\t  for (i = 1; i < len; i++)\r\n\t   args[i - 1] = arguments[i];\r\n\t\r\n\t  listeners = handler.slice();\r\n\t  len = listeners.length;\r\n\t  for (i = 0; i < len; i++){\r\n\t      // a small hack put in to be able to stop event emission\r\n\t      var r = listeners[i].apply(this, args);\r\n\t      if(r === 'stopEvent') break;\r\n\t  }\r\n\t\r\n\t }\r\n\t\r\n\t return true;\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.addListener = function(type, listener) {\r\n\t var m;\r\n\t\r\n\t if (!isFunction(listener))\r\n\t  throw TypeError('listener must be a function');\r\n\t\r\n\t if (!this._events)\r\n\t  this._events = {};\r\n\t\r\n\t // To avoid recursion in the case that type === \"newListener\"! Before\r\n\t // adding it to the listeners, first emit \"newListener\".\r\n\t if (this._events.newListener)\r\n\t  this.emit('newListener', type,\r\n\t      isFunction(listener.listener) ?\r\n\t          listener.listener : listener);\r\n\t\r\n\t if (!this._events[type])\r\n\t // Optimize the case of one listener. Don't need the extra array object.\r\n\t  this._events[type] = listener;\r\n\t else if (isObject(this._events[type]))\r\n\t // If we've already got an array, just append.\r\n\t  this._events[type].push(listener);\r\n\t else\r\n\t // Adding the second element, need to change to array.\r\n\t  this._events[type] = [this._events[type], listener];\r\n\t\r\n\t // Check for listener leak\r\n\t if (isObject(this._events[type]) && !this._events[type].warned) {\r\n\t  var m;\r\n\t  if (!isUndefined(this._maxListeners)) {\r\n\t   m = this._maxListeners;\r\n\t  } else {\r\n\t   m = EventEmitter.defaultMaxListeners;\r\n\t  }\r\n\t\r\n\t  if (m && m > 0 && this._events[type].length > m) {\r\n\t   this._events[type].warned = true;\r\n\t   console.error('(node) warning: possible EventEmitter memory ' +\r\n\t       'leak detected. %d listeners added. ' +\r\n\t       'Use emitter.setMaxListeners() to increase limit.',\r\n\t       this._events[type].length);\r\n\t   if (typeof console.trace === 'function') {\r\n\t    // not supported in IE 10\r\n\t    console.trace();\r\n\t   }\r\n\t  }\r\n\t }\r\n\t\r\n\t return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds a listener for the event.\r\n\t * @param {String} type The event name to listen to\r\n\t * @param {Function} listener The function to invoke when the event occurs\r\n\t * @returns EventEmitter\r\n\t *\r\n\t */\r\n\tEventEmitter.prototype.on = function(type, listener){\r\n\t    EventEmitter.prototype.addListener.apply(this,arguments);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed.\r\n\t * @param {String} type The event name to listen to\r\n\t * @param {Function} listener The function to invoke when the event occurs\r\n\t * @returns EventEmitter\r\n\t *\r\n\t */\r\n\tEventEmitter.prototype.once = function(type, listener) {\r\n\t if (!isFunction(listener))\r\n\t  throw TypeError('listener must be a function');\r\n\t\r\n\t var fired = false;\r\n\t\r\n\t function g() {\r\n\t  this.removeListener(type, g);\r\n\t\r\n\t  if (!fired) {\r\n\t   fired = true;\r\n\t   listener.apply(this, arguments);\r\n\t  }\r\n\t }\r\n\t\r\n\t g.listener = listener;\r\n\t this.on(type, g);\r\n\t\r\n\t return this;\r\n\t};\r\n\t\r\n\t// emits a 'removeListener' event iff the listener was removed\r\n\tEventEmitter.prototype.removeListener = function(type, listener) {\r\n\t var list, position, length, i;\r\n\t\r\n\t if (!isFunction(listener))\r\n\t  throw TypeError('listener must be a function');\r\n\t\r\n\t if (!this._events || !this._events[type])\r\n\t  return this;\r\n\t\r\n\t list = this._events[type];\r\n\t length = list.length;\r\n\t position = -1;\r\n\t\r\n\t if (list === listener ||\r\n\t     (isFunction(list.listener) && list.listener === listener)) {\r\n\t  delete this._events[type];\r\n\t  if (this._events.removeListener)\r\n\t   this.emit('removeListener', type, listener);\r\n\t\r\n\t } else if (isObject(list)) {\r\n\t  for (i = length; i-- > 0;) {\r\n\t   if (list[i] === listener ||\r\n\t       (list[i].listener && list[i].listener === listener)) {\r\n\t    position = i;\r\n\t    break;\r\n\t   }\r\n\t  }\r\n\t\r\n\t  if (position < 0)\r\n\t   return this;\r\n\t\r\n\t  if (list.length === 1) {\r\n\t   list.length = 0;\r\n\t   delete this._events[type];\r\n\t  } else {\r\n\t   list.splice(position, 1);\r\n\t  }\r\n\t\r\n\t  if (this._events.removeListener)\r\n\t   this.emit('removeListener', type, listener);\r\n\t }\r\n\t\r\n\t return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Alias for removeListener\r\n\t * @param {String} type The event name to stop listening to\r\n\t * @param {Function} listener The function that was originally add to handle the event\r\n\t * @returns EventEmitter\r\n\t *\r\n\t */\r\n\tEventEmitter.prototype.off = function(type, listener){\r\n\t    EventEmitter.prototype.removeListener.apply(this,arguments);\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Removes all listeners, or those of the specified event.\r\n\t * @param {String} event The event name to stop listening to\r\n\t * @returns EventEmitter\r\n\t *\r\n\t */\r\n\tEventEmitter.prototype.removeAllListeners = function(type) {\r\n\t var key, listeners;\r\n\t\r\n\t if (!this._events)\r\n\t  return this;\r\n\t\r\n\t // not listening for removeListener, no need to emit\r\n\t if (!this._events.removeListener) {\r\n\t  if (arguments.length === 0)\r\n\t   this._events = {};\r\n\t  else if (this._events[type])\r\n\t   delete this._events[type];\r\n\t  return this;\r\n\t }\r\n\t\r\n\t // emit removeListener for all listeners on all events\r\n\t if (arguments.length === 0) {\r\n\t  for (key in this._events) {\r\n\t   if (key === 'removeListener') continue;\r\n\t   this.removeAllListeners(key);\r\n\t  }\r\n\t  this.removeAllListeners('removeListener');\r\n\t  this._events = {};\r\n\t  return this;\r\n\t }\r\n\t\r\n\t listeners = this._events[type];\r\n\t\r\n\t if (isFunction(listeners)) {\r\n\t  this.removeListener(type, listeners);\r\n\t } else {\r\n\t  // LIFO order\r\n\t  while (listeners.length)\r\n\t   this.removeListener(type, listeners[listeners.length - 1]);\r\n\t }\r\n\t delete this._events[type];\r\n\t\r\n\t return this;\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.listeners = function(type) {\r\n\t var ret;\r\n\t if (!this._events || !this._events[type])\r\n\t  ret = [];\r\n\t else if (isFunction(this._events[type]))\r\n\t  ret = [this._events[type]];\r\n\t else\r\n\t  ret = this._events[type].slice();\r\n\t return ret;\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.disableEvent = function(type) {\r\n\t    if(type && typeof type === 'string'){\r\n\t        this._disabledEvents[type] = true;\r\n\t    }\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.enableEvent = function(type) {\r\n\t    if(type && typeof type === 'string'){\r\n\t        delete this._disabledEvents[type];\r\n\t    }\r\n\t};\r\n\t\r\n\tEventEmitter.listenerCount = function(emitter, type) {\r\n\t var ret;\r\n\t if (!emitter._events || !emitter._events[type])\r\n\t  ret = 0;\r\n\t else if (isFunction(emitter._events[type]))\r\n\t  ret = 1;\r\n\t else\r\n\t  ret = emitter._events[type].length;\r\n\t return ret;\r\n\t};\r\n\t\r\n\tfunction isFunction(arg) {\r\n\t return typeof arg === 'function';\r\n\t}\r\n\t\r\n\tfunction isNumber(arg) {\r\n\t return typeof arg === 'number';\r\n\t}\r\n\t\r\n\tfunction isObject(arg) {\r\n\t return typeof arg === 'object' && arg !== null;\r\n\t}\r\n\t\r\n\tfunction isUndefined(arg) {\r\n\t return arg === void 0;\r\n\t}\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar props = util.props;\r\n\tvar Application = __webpack_require__(6);\r\n\tvar Channel = __webpack_require__(7);\r\n\t\r\n\t\r\n\t/**\r\n\t * A Service instance represents the multiscreen service running on the remote device, such as a SmartTV\r\n\t *\r\n\t * @class Service\r\n\t * @hide-constructor\r\n\t *\r\n\t */\r\n\t\r\n\tfunction Service(description){\r\n\t\r\n\t    /**\r\n\t     * The id of the service\r\n\t     *\r\n\t     * @member {String} Service#id\r\n\t     * @readonly\r\n\t     */\r\n\t    this.id = description.id;\r\n\t\r\n\t    /**\r\n\t     * The name of the service (Living Room TV)\r\n\t     *\r\n\t     * @member {String} Service#name\r\n\t     * @readonly\r\n\t     */\r\n\t    this.name = description.name;\r\n\t\r\n\t    /**\r\n\t     * The version of the service (x.x.x)\r\n\t     *\r\n\t     * @member {String} Service#version\r\n\t     * @readonly\r\n\t     */\r\n\t    this.version = description.version;\r\n\t\r\n\t    /**\r\n\t     * The type of the service (Samsung SmartTV)\r\n\t     *\r\n\t     * @member {String} Service#type\r\n\t     * @readonly\r\n\t     */\r\n\t    this.type = description.type;\r\n\t\r\n\t    /**\r\n\t     * The uri of the service (http://<ip>:<port>/api/v2/)\r\n\t     *\r\n\t     * @member {String} Service#uri\r\n\t     * @readonly\r\n\t     */\r\n\t    this.uri = description.uri;\r\n\t\r\n\t    /**\r\n\t     * A hash of additional information about the device the service is running on\r\n\t     *\r\n\t     * @member {String} Service#device\r\n\t     * @readonly\r\n\t     */\r\n\t    this.device = description.device;\r\n\t\r\n\t    props.readOnly(this,['id','name','version','type','uri','device']);\r\n\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates {@link Application} instances belonging to that service\r\n\t *\r\n\t * @param {String} id An installed application id or url of the web application\r\n\t * @param {String} channelUri The URI of the channel to connect to.\r\n\t * @returns {Application}\r\n\t *\r\n\t * @example\r\n\t var application = service.application('http://mydomain/myapp/', 'com.mydomain.myapp');\r\n\t */\r\n\tService.prototype.application = function(id, channelUri){\r\n\t\r\n\t    return new Application(this, id, channelUri);\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * creates a channel of the service ('mychannel')\r\n\t *\r\n\t * @param {String} uri The uri of the Channel\r\n\t * @returns {Channel}\r\n\t *\r\n\t * @example\r\n\t var channel = service.channel('com.mydomain.myapp');\r\n\t */\r\n\tService.prototype.channel = function(uri){\r\n\t\r\n\t    return new Channel(this, uri);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/***\r\n\t * Retrieves a reference to the service running on the current device\r\n\t * (public api should use msf.local)\r\n\t *\r\n\t * @protected\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Error} callback.err The callback handler\r\n\t * @param {Service} callback.service The service instance\r\n\t *\r\n\t */\r\n\tService.getLocal = function(callback){\r\n\t\r\n\t    Service.getByURI('http://127.0.0.1:8001/api/v2/', callback);\r\n\t\r\n\t};\r\n\t\r\n\t/***\r\n\t * Retrieves a service instance by it's uri\r\n\t * (public api should use msf.remote)\r\n\t *\r\n\t * @protected\r\n\t *\r\n\t * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Error} callback.err The callback handler\r\n\t * @param {Service} callback.service The service instance\r\n\t *\r\n\t */\r\n\tService.getByURI = function(uri, callback){\r\n\t\r\n\t    var oReq = new XMLHttpRequest();\r\n\t    oReq.timeout = 5000;\r\n\t    oReq.ontimeout = function(){callback();};\r\n\t    oReq.onload = function() {\r\n\t\r\n\t        if(this.status === 200){\r\n\t            try{\r\n\t                var result = JSON.parse(this.responseText);\r\n\t                callback(null, new Service(result));\r\n\t            }catch(e){  callback(e); }\r\n\t        }else{\r\n\t            callback();\r\n\t        }\r\n\t    };\r\n\t    oReq.open(\"get\", uri, true);\r\n\t    oReq.send();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tmodule.exports = Service;\r\n\t\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar props = util.props;\r\n\tvar EventEmitter = __webpack_require__(2);\r\n\t\r\n\t\r\n\t/**\r\n\t * Provides members related to {@link Service} discovery.\r\n\t *\r\n\t * @class Search\r\n\t * @extends EventEmitter\r\n\t * @hide-constructor\r\n\t *\r\n\t */\r\n\t\r\n\tfunction Search(){\r\n\t\r\n\t\r\n\t    Search.super_.call(this);\r\n\t\r\n\t    this.discoveryFrame = null;\r\n\t    this.status = Search.STATUS_STOPPED;\r\n\t\r\n\t    var self = this;\r\n\t\r\n\t    /* Create the discovery iframe and load the search page */\r\n\t\r\n\t    var frame = document.createElement('iframe');\r\n\t    frame.setAttribute('width', '1');\r\n\t    frame.setAttribute('height', '1');\r\n\t    frame.style.display = \"none\";\r\n\t    frame.src = 'http://multiscreen.samsung.com/discoveryservice/v2/discover';\r\n\t    document.body.appendChild(frame);\r\n\t\r\n\t    /* Add a 'message' listener to the window that checks incoming messages */\r\n\t\r\n\t    this.windowMessageListener = function(event){\r\n\t\r\n\t        if(event.source === frame.contentWindow){\r\n\t\r\n\t            // ready message\r\n\t            if(event.data && event.data.event === 'discovery.ready'){\r\n\t                self.discoveryFrame = event.source;\r\n\t                self.onSearchReady();\r\n\t            }\r\n\t\r\n\t            // result message\r\n\t            else if(event.data && event.data.event === 'discovery.result'){\r\n\t                var results = [];\r\n\t                var Service = __webpack_require__(3);\r\n\t                for(var i=0; i<event.data.result.length; i++){\r\n\t                    results.push(new Service(event.data.result[i]));\r\n\t                }\r\n\t                self.onSearchResult(results);\r\n\t            }\r\n\t\r\n\t            // error message\r\n\t            else if(event.data && event.data.event === 'discovery.error'){\r\n\t                self.onSearchError(event.data.error);\r\n\t                this.status = Search.STATUS_STOPPED;\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    window.addEventListener('message', this.windowMessageListener);\r\n\t\r\n\t    props.private(this,['discoveryFrame','windowMessageListener']);\r\n\t\r\n\t}\r\n\t\r\n\tutil.inherits(Search, EventEmitter);\r\n\t\r\n\t\r\n\t/***\r\n\t * @constant {string}\r\n\t * @private\r\n\t */\r\n\tSearch.STATUS_STOPPED = 'stopped';\r\n\t\r\n\t/***\r\n\t * @constant {string}\r\n\t * @private\r\n\t */\r\n\tSearch.STATUS_STARTED = 'started';\r\n\t\r\n\t\r\n\t/**\r\n\t * Starts the search, looking for devices it can reach on the network\r\n\t * If a search is already in progress it will NOT begin a new search\r\n\t *\r\n\t * @example\r\n\t *\r\n\t * var search = msf.search();\r\n\t * search.on('found', function(service){\r\n\t *    console.log('found service '+service.name);\r\n\t * }\r\n\t * search.start();\r\n\t *\r\n\t */\r\n\tSearch.prototype.start = function(){\r\n\t    if(this.status === Search.STATUS_STOPPED){\r\n\t        if(this.discoveryFrame){\r\n\t            this.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\r\n\t        }else{\r\n\t            var self = this;\r\n\t            this.once('ready',function(){\r\n\t                self.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\r\n\t            });\r\n\t        }\r\n\t        this.onSearchStart();\r\n\t    }else{\r\n\t        console.warn('a previous search is already in progress');\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * Stops the current search in progress (no 'found' events or search callbacks will fire)\r\n\t *\r\n\t * @example\r\n\t * search.stop();\r\n\t *\r\n\t */\r\n\tSearch.prototype.stop = function(){\r\n\t    this.onSearchStop();\r\n\t};\r\n\t\r\n\tSearch.prototype.onSearchReady = function(){\r\n\t    this.emit('ready');\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Fired when a search has discovered compatible services\r\n\t *\r\n\t * @event Search#found\r\n\t * @type {Array}\r\n\t * @example\r\n\t * search.on('found', function(service){\r\n\t *    console.log('found '+service.name);\r\n\t * });\r\n\t */\r\n\t\r\n\t\r\n\tSearch.prototype.onSearchResult = function(results){\r\n\t    if(this.status !== Search.STATUS_STOPPED){\r\n\t        this.emit('found',results);\r\n\t    }\r\n\t    this.status = Search.STATUS_STOPPED;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Fired when a search error has occurred\r\n\t *\r\n\t * @event Search#error\r\n\t * @type {Error}\r\n\t * @example\r\n\t * search.on('error', function(err){\r\n\t *    console.error('something went wrong', err.message);\r\n\t * });\r\n\t */\r\n\t\r\n\tSearch.prototype.onSearchError = function(error){\r\n\t    this.emit('error',error);\r\n\t    this.status = Search.STATUS_STOPPED;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Fired when a search has been started\r\n\t *\r\n\t * @event Search#start\r\n\t * @type {Search}\r\n\t *\r\n\t * @example\r\n\t * search.on('start', function(){\r\n\t *    ui.setState('searching');\r\n\t * });\r\n\t */\r\n\tSearch.prototype.onSearchStart = function(){\r\n\t    this.status = Search.STATUS_STARTED;\r\n\t    this.emit('start', this);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Fired when a search has been stopped\r\n\t *\r\n\t * @event Search#stop\r\n\t * @type {Search}\r\n\t * @example\r\n\t * search.on('stop', function(){\r\n\t *    ui.setState('stopped');\r\n\t * });\r\n\t */\r\n\tSearch.prototype.onSearchStop = function(){\r\n\t    this.status = Search.STATUS_STOPPED;\r\n\t    this.emit('stop', this);\r\n\t};\r\n\t\r\n\t\r\n\tmodule.exports = Search;\r\n\t\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\r\n\t\r\n\t    logger      : __webpack_require__(8),\r\n\t    url         : __webpack_require__(9),\r\n\t    inherits    : __webpack_require__(10),\r\n\t    props       : __webpack_require__(11),\r\n\t    types       : __webpack_require__(12),\r\n\t    queryString : __webpack_require__(13)\r\n\t\r\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util    = __webpack_require__(5);\r\n\tvar logger  = util.logger;\r\n\tvar types   = util.types;\r\n\tvar props   = util.props;\r\n\tvar Channel = __webpack_require__(7);\r\n\t\r\n\t\r\n\tvar TYPE_APP = 'applications';\r\n\tvar TYPE_WEB_APP = 'webapplication';\r\n\t\r\n\t\r\n\t/**\r\n\t * An Application represents an application on the remote device.\r\n\t * Use the class to control various aspects of the application such launching the app or getting information\r\n\t *\r\n\t * @class Application\r\n\t * @extends Channel\r\n\t *\r\n\t * @param {Service} service the underlying service\r\n\t * @param {String} id can be an installed app id or url for a webapp\r\n\t * @param {String} channelURI a unique channel id (com.myapp.mychannel)\r\n\t *\r\n\t * @hide-constructor\r\n\t */\r\n\t\r\n\tfunction Application(service, id, channelURI){\r\n\t\r\n\t    /* Type checking */\r\n\t    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\r\n\t    if(!types.isString(id)) throw new TypeError('id must be a valid string');\r\n\t    if(!types.isString(channelURI)) throw new TypeError('channelId must be a valid string');\r\n\t\r\n\t    /***\r\n\t     * The type of application (web application or installable app)\r\n\t     * @member {String} Application#type\r\n\t     * @private\r\n\t     */\r\n\t    this.type = id.match(/(file:\\/\\/|http(s)?:\\/\\/)/gmi) ? TYPE_WEB_APP : TYPE_APP;\r\n\t\r\n\t    /* Super Constructor */\r\n\t    Application.super_.call(this, service, channelURI);\r\n\t\r\n\t\r\n\t    /**\r\n\t     * The id of the application (this can be a url or installed application id)\r\n\t     * @member {String} Application#id\r\n\t     * @readonly\r\n\t     */\r\n\t    this.id = id;\r\n\t\r\n\t\r\n\t    /***\r\n\t     * The underlying of the application\r\n\t     * @member {String} Application#service\r\n\t     * @private\r\n\t     */\r\n\t    this.service = service;\r\n\t\r\n\t\r\n\t    /*\r\n\t    Listen for clientDisconnect events and disconnect if host disconnects\r\n\t    */\r\n\t    this.on('clientDisconnect', function(client){\r\n\t        if(client.isHost) this.disconnect();\r\n\t    }.bind(this));\r\n\t\r\n\t    /*\r\n\t     Turn off emitting the connect event from super as the application will provide its own\r\n\t    */\r\n\t    this.disableEvent('connect');\r\n\t\r\n\t\r\n\t    props.readOnly(this,'id');\r\n\t    props.private(this,'type','service');\r\n\t\r\n\t}\r\n\t\r\n\tutil.inherits(Application, Channel);\r\n\t\r\n\t\r\n\t\r\n\t/**\r\n\t * Starts and connects to the application on the remote device. Similar to the Channel 'connect' method but\r\n\t * within an Application the 'connect' callback and event will be only be called when the remote application has\r\n\t * launched and is ready to receive messages.\r\n\t *\r\n\t * @param {Object} attributes Any attributes to attach to your client\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Error} callback.error Any error that may have occurred during the connection or application startup\r\n\t * @param {Client} callback.client Your client object\r\n\t *\r\n\t * @example\r\n\t * app.connect({displayName:'Wheezy'},function(err, client){\r\n\t *   if(err) return console.error('something went wrong : ', error.code, error.message);\r\n\t *   console.info('You are now connected');\r\n\t * });\r\n\t */\r\n\tApplication.prototype.connect = function(attributes, callback){\r\n\t\r\n\t    if(!types.isObject(attributes)) throw new TypeError('attributes must be a valid object');\r\n\t    if(!types.isFunction(callback)) throw new TypeError('callback must be a valid function');\r\n\t\r\n\t    /*\r\n\t     This gets a little tricky because in an app instance we dont want connect to fire until the remote device is connected.\r\n\t     We also want to start the remote application and provide any errors from the launch\r\n\t     so we need to block the connect event from Channel, start the app, wait for the host to connect, have ready event (deprecated) trigger connect event.\r\n\t     */\r\n\t\r\n\t   this.start(function(err){\r\n\t\r\n\t       // If there was an issue starting the app callback with the error and stop execution\r\n\t       if(err) return callback(err);\r\n\t\r\n\t       // Call connect on the super\r\n\t       Channel.prototype.connect.call(this, attributes, function(err, client){\r\n\t\r\n\t           if(err) return callback(err);\r\n\t\r\n\t           // Set the connected flag to false until ready event fires\r\n\t           this.connected = false;\r\n\t\r\n\t           // Create a once listener for the ready event that will make the final callback and fire the connect event\r\n\t           var readyHandler = function(){\r\n\t\r\n\t               // Set the connected property\r\n\t               this.connected = true;\r\n\t\r\n\t               // call the connect callback\r\n\t               if(callback) {\r\n\t                   logger.debug('application.connect->callback', null, client);\r\n\t                   callback(null, client);\r\n\t               }\r\n\t\r\n\t               // enable the connect event, fire it, disable it again\r\n\t               logger.debug('application.emit(\"connect\")', client);\r\n\t               this.enableEvent('connect');\r\n\t               this.emit('connect',client);\r\n\t               this.disableEvent('connect');\r\n\t\r\n\t           }.bind(this);\r\n\t\r\n\t           // Listen once for the ready event\r\n\t           this.once('ready',readyHandler);\r\n\t\r\n\t       }.bind(this));\r\n\t\r\n\t   }.bind(this));\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Disconnects your client from the remote application.\r\n\t * If the first argument is an optional param and can be used close the remote application\r\n\t * The stop/exit command is only sent if you are the last connected client\r\n\t *\r\n\t * @param {Boolean} [exitOnRemote=true] Issues a stop/exit on the remote application before disconnecting\r\n\t * @param {Function} [callback] The callback handler\r\n\t * @param {Error} callback.error Any error that may have occurred during the connection or application startup\r\n\t * @param {Client} callback.client Your client object\r\n\t *\r\n\t * @example\r\n\t * app.disconnect(function(err){\r\n\t *     if(err) return console.error('something went wrong');\r\n\t *     console.info('You are now disconnected');\r\n\t * });\r\n\t */\r\n\tApplication.prototype.disconnect = function(exitOnRemote, callback){\r\n\t\r\n\t    if(types.isFunction(exitOnRemote)){\r\n\t        callback = exitOnRemote;\r\n\t        exitOnRemote = true;\r\n\t    }\r\n\t\r\n\t    if(types.isUndefined(exitOnRemote)) exitOnRemote = true;\r\n\t\r\n\t\r\n\t    if(exitOnRemote && this.clients.length <= 2) {\r\n\t\r\n\t        var stopCallback = function(err){\r\n\t            // still disconnect even if there was an error\r\n\t            Channel.prototype.disconnect.call(this, callback);\r\n\t        }.bind(this);\r\n\t\r\n\t        if(this.type === 'webapplication'){\r\n\t            this.invoke('ms.webapplication.stop', { url : this.id }, stopCallback);\r\n\t        }else{\r\n\t            this.invoke('ms.application.stop', { id : this.id }, stopCallback);\r\n\t        }\r\n\t\r\n\t    }else{\r\n\t        Channel.prototype.disconnect.call(this, callback);\r\n\t    }\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Installs the application on the remote device.\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Function} callback.err The callback handler\r\n\t *\r\n\t * @example\r\n\t *  app.connect({name:'Jason'}, function(err, client){\r\n\t *    if(err.code === 404){\r\n\t *      var install = confirm('Would you like to install the MyApp on your TV?');\r\n\t *      if(install){\r\n\t *         app.install(function(err){\r\n\t *            alert('Please follow the prompts on your TV to install the application');\r\n\t *         });\r\n\t *     }\r\n\t *   }\r\n\t *  });\r\n\t */\r\n\tApplication.prototype.install = function(callback){\r\n\t\r\n\t    if(this.type === TYPE_WEB_APP) return callback(new Error('web application cannot be installed'));\r\n\t\r\n\t    var e;\r\n\t    var req = new XMLHttpRequest();\r\n\t    req.timeout = 10000;\r\n\t\r\n\t    req.ontimeout = function(){\r\n\t        e = new Error('Request Timeout');\r\n\t        e.code = 408;\r\n\t        callback(e);\r\n\t    };\r\n\t\r\n\t    req.onload = function() {\r\n\t        if(this.status === 200){\r\n\t            callback(null, true);\r\n\t        }\r\n\t        else {\r\n\t            e = new Error(this.statusText);\r\n\t            e.code = this.status;\r\n\t            callback(e);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    req.open(\"get\", this.service.uri + 'applications/'+this.id, true);\r\n\t    req.send();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/***\r\n\t * Starts the application on the remote device.\r\n\t *\r\n\t * @private\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Function} callback.err The callback handler\r\n\t *\r\n\t */\r\n\tApplication.prototype.start = function(callback){\r\n\t\r\n\t    var e;\r\n\t\r\n\t    var req = new XMLHttpRequest();\r\n\t    req.timeout = 10000;\r\n\t\r\n\t    req.ontimeout = function(){\r\n\t        e = new Error('Request Timeout');\r\n\t        e.code = 408;\r\n\t        callback(e);\r\n\t    };\r\n\t\r\n\t    req.onload = function() {\r\n\t        if(this.status === 200){\r\n\t            callback(null, true);\r\n\t        }\r\n\t        else {\r\n\t            e = new Error(this.statusText);\r\n\t            e.code = this.status;\r\n\t            callback(e);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    if(this.type === TYPE_WEB_APP){\r\n\t        req.open(\"post\", this.service.uri + 'webapplication/', true);\r\n\t        req.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\r\n\t        req.send(JSON.stringify({url:this.id}));\r\n\t    }else{\r\n\t        req.open(\"post\", this.service.uri + 'applications/'+this.id, true);\r\n\t        req.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\r\n\t        req.send(JSON.stringify({}));\r\n\t    }\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\tmodule.exports = Application;\r\n\t\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util    = __webpack_require__(5);\r\n\tvar logger  = util.logger;\r\n\tvar types   = util.types;\r\n\tvar props   = util.props;\r\n\tvar EventEmitter = __webpack_require__(2);\r\n\tvar Client = __webpack_require__(14);\r\n\tvar ClientList = __webpack_require__(15);\r\n\t\r\n\tvar EVENT_HEALTH_CHECK = '__ping';\r\n\t\r\n\t\r\n\t/**\r\n\t * A Channel is a discreet connection where multiple clients can communicate\r\n\t * @class Channel\r\n\t * @extends EventEmitter\r\n\t *\r\n\t * @hide-constructor\r\n\t */\r\n\tfunction Channel(service, uri){\r\n\t\r\n\t    logger.debug('new Channel',arguments);\r\n\t\r\n\t    /* Type checking */\r\n\t    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\r\n\t    if(!types.isString(uri)) throw new TypeError('uri must be a valid string');\r\n\t\r\n\t    /* Super Construction */\r\n\t    Channel.super_.call(this);\r\n\t\r\n\t    var self = this;\r\n\t    var oServiceUrl = util.url.parse(service.uri);\r\n\t\r\n\t\r\n\t    /***\r\n\t     * The connected state of the channel (a backing variable to isConnected)\r\n\t     * @protected\r\n\t     */\r\n\t    this.connected = false;\r\n\t\r\n\t    /***\r\n\t     * The id assigned to your client upon connection\r\n\t     * @private\r\n\t     */\r\n\t    this.clientId = null;\r\n\t\r\n\t    /***\r\n\t     * The underlying web socket connection\r\n\t     * @private\r\n\t     */\r\n\t    this.connection = null;\r\n\t\r\n\t    /***\r\n\t     * A map of message handler still waiting for responses\r\n\t     * @private\r\n\t     */\r\n\t    this.resultHandlers = {};\r\n\t\r\n\t    /***\r\n\t     * The url for the websocket to connect to\r\n\t     * @private\r\n\t     */\r\n\t    this.connectionUrl = 'ws://' + oServiceUrl.host + oServiceUrl.pathname + 'channels/' + uri;\r\n\t\r\n\t    /***\r\n\t     * The time in milliseconds between pings if a connection timeout is defined\r\n\t     * @private\r\n\t     */\r\n\t    this.pingTimeout = null;\r\n\t\r\n\t    /***\r\n\t     * The 'interval' reference set with setConnectionTimeout\r\n\t     * @private\r\n\t     */\r\n\t    this.pingInterval = null;\r\n\t\r\n\t\r\n\t    /**\r\n\t     * The collection of clients currently connected to the channel\r\n\t     *\r\n\t     * @member {ClientList} Channel#clients\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.clients = new ClientList(this);\r\n\t\r\n\t    /**\r\n\t     * The connection status of the channel\r\n\t     *\r\n\t     * @member {Boolean} Channel#isConnected\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    Object.defineProperty(this, 'isConnected', {\r\n\t        get : function(){\r\n\t            return self.connected;\r\n\t        }\r\n\t    });\r\n\t\r\n\t\r\n\t    /**\r\n\t     * Sets the connection timeout. When set the channel will utilize a connection health check while connected.\r\n\t     * If no pinging health check is not received within the given timeout the connection will close.\r\n\t     * To stop the health check set the timeout to 0\r\n\t     *\r\n\t     * @member {Boolean} Channel#connectionTimeout\r\n\t     *\r\n\t     * @example\r\n\t     * channel.connectionTimeout = 10000; // checks the connection every 10 seconds while connected\r\n\t     * channel.connectionTimeout = 0; // stops the health check\r\n\t     */\r\n\t    Object.defineProperty(this, 'connectionTimeout', {\r\n\t        set : function(timeout){\r\n\t            logger.debug('updating connection timeout ',timeout);\r\n\t            self.pingTimeout = timeout > 0 ? timeout : 0;\r\n\t            // If we are already connected start the check\r\n\t            if(this.isConnected) self.startHealthCheck();\r\n\t        },\r\n\t        get : function(){\r\n\t            return self.pingTimeout;\r\n\t        }\r\n\t    });\r\n\t\r\n\t\r\n\t\r\n\t    /* setup health check listeners */\r\n\t    this.on('connect', this.startHealthCheck);\r\n\t    this.on('disconnect', this.stopHealthCheck);\r\n\t\r\n\t\r\n\t    /* configure access and enumeration of properties */\r\n\t    props.readOnly(this, ['clients']);\r\n\t    props.private(this, [\r\n\t        'connected',\r\n\t        'clientId',\r\n\t        'connection',\r\n\t        'resultHandlers',\r\n\t        'connectionUrl',\r\n\t        'connectCallback',\r\n\t        'pingInterval',\r\n\t        'pingTimeout',\r\n\t        'lastPingReceived'\r\n\t    ]);\r\n\t\r\n\t}\r\n\t\r\n\t\r\n\tutil.inherits(Channel, EventEmitter);\r\n\t\r\n\t\r\n\t\r\n\t/**\r\n\t * Connects to the channel\r\n\t *\r\n\t * @param {Object} attributes Any attributes you want to associate with the client (ie. {name:\"FooBar\"}\r\n\t * @param {Function} callback The success callback handler\r\n\t * @param {Error} callback.arg1 Any error that may have occurred\r\n\t * @param {Client} callback.arg2 The connecting client\r\n\t *\r\n\t * @example\r\n\t * channel.connect({name:'Wheezy'},function(err, client){\r\n\t *   if(err) return console.error('something went wrong : ', error.code, error.message);\r\n\t *   console.info(client.attributes.name+', you are now connected');\r\n\t * });\r\n\t */\r\n\tChannel.prototype.connect = function(attributes, callback){\r\n\t\r\n\t    logger.debug('channel.connect',arguments);\r\n\t    if(this.isConnected) return console.warn('Channel is already connected.');\r\n\t\r\n\t    if(types.isFunction(attributes) && !callback){\r\n\t        callback = attributes;\r\n\t        attributes = {};\r\n\t    }else{\r\n\t        attributes = attributes || {};\r\n\t    }\r\n\t\r\n\t    // Validate arguments and connection state\r\n\t    if(!types.isObject(attributes))throw new TypeError('attributes must be a valid object');\r\n\t    if(callback && !types.isFunction(callback))throw new TypeError('callback must be a valid function');\r\n\t\r\n\t\r\n\t    // Store the callback\r\n\t    this.connectCallback = callback;\r\n\t\r\n\t    // TODO : Need to merge query string just in case the connection url already has a query (although it shouldn't)\r\n\t    var u = this.connectionUrl + '?' + util.queryString.stringify(attributes);\r\n\t\r\n\t    // Clean up any old connections\r\n\t    if(this.connection){\r\n\t        this.connection.onopen = null;\r\n\t        this.connection.onerror = null;\r\n\t        this.connection.onclose = null;\r\n\t        this.connection.onmessage = null;\r\n\t    }\r\n\t\r\n\t    // Connect the websocket and add our listeners\r\n\t    this.connection = new WebSocket(u);\r\n\t    this.connection.binaryType = \"arraybuffer\";\r\n\t    this.connection.onopen = this._onSocketOpen.bind(this);\r\n\t    this.connection.onerror = this._onSocketError.bind(this);\r\n\t    this.connection.onclose = this._onSocketClose.bind(this);\r\n\t    this.connection.onmessage = this._onSocketMessage.bind(this);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Disconnects from the channel\r\n\t *\r\n\t * @param {Function} callback The success callback handler\r\n\t * @param {Error} callback.error Any error that may have occurred\r\n\t * @param {Client} callback.client The disconnecting client\r\n\t *\r\n\t * @example\r\n\t * channel.disconnect(function(err, client){\r\n\t *   if(err) return console.error('something went wrong : ', error.code, error.message);\r\n\t *   console.info(client.attributes.name+', you are now disconnected');\r\n\t * });\r\n\t */\r\n\tChannel.prototype.disconnect = function(callback){\r\n\t\r\n\t    logger.debug('channel.disconnect',arguments);\r\n\t    if(!this.isConnected) console.warn(\"channel is already disconnected\");\r\n\t\r\n\t    this.connection.close();\r\n\t    var self = this;\r\n\t    setTimeout(function(){\r\n\t        if(callback) callback(null, self);\r\n\t    },0);\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Publish an event message to the specified target or targets.\r\n\t * Targets can be in the for of a clients id, an array of client ids or one of the special message target strings (ie. \"all\" or \"host\"}\r\n\t *\r\n\t * @param {String} event The name of the event to emit\r\n\t * @param {any} [message] Any data associated with the event\r\n\t * @param {String|Array} [target='broadcast'] The target recipient(s) of the message\r\n\t * @param {Blob|ArrayBuffer} [payload] Any binary data to send with the message\r\n\t *\r\n\t * @example\r\n\t * channel.publish('myCustomEventName',{custom:'data'});\r\n\t */\r\n\tChannel.prototype.publish = function(event, message, target, payload){\r\n\t\r\n\t    logger.silly('channel.publish',arguments);\r\n\t    if(!this.isConnected) return console.warn('Channel is not connected.');\r\n\t\r\n\t    target = target || 'broadcast';\r\n\t    message = message || null;\r\n\t\r\n\t\r\n\t    if(!types.isString(event))throw new TypeError('event must be a valid string');\r\n\t    if(!(types.isString(target) || types.isArray(target))) throw new TypeError('targets must be a valid string or array');\r\n\t\r\n\t    this.invoke('ms.channel.emit',{\r\n\t        event   : event,\r\n\t        data    : message,\r\n\t        to      : target\r\n\t    }, null, true, payload);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t/*\r\n\t Packs messages with payloads into binary message\r\n\t */\r\n\tChannel.packMessage = function(oMsg, payload){\r\n\t\r\n\t    logger.debug('channel.packMessage',arguments);\r\n\t\r\n\t    // convert js object to string\r\n\t    var msg = JSON.stringify(oMsg);\r\n\t\r\n\t    // get byte length of the string\r\n\t    var msgByteLength = new Blob([msg]).size;\r\n\t\r\n\t    // create 2 byte header which contains the length of the string (json) message\r\n\t    var hBuff = new ArrayBuffer(2);\r\n\t    var hView = new DataView(hBuff);\r\n\t    hView.setUint16(0,msgByteLength);\r\n\t\r\n\t    // binary packed message and payload\r\n\t    return new Blob([hBuff, msg, payload]);\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\t Unpacks binary messages\r\n\t */\r\n\tChannel.unpackMessage = function(buffer){\r\n\t\r\n\t    logger.debug('channel.unpackMessage',arguments);\r\n\t\r\n\t    var json = '';\r\n\t    var view = new DataView(buffer);\r\n\t    var msgByteLen = view.getUint16(0);\r\n\t\r\n\t    for (var i = 0; i < msgByteLen; i++) {\r\n\t        json += String.fromCharCode(view.getUint8(i+2));\r\n\t    }\r\n\t\r\n\t    var payload = buffer.slice(2+msgByteLen);\r\n\t    var message = JSON.parse(json);\r\n\t\r\n\t    return {payload : payload, message : message};\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t/***\r\n\t * Invokes and RPC method on the server\r\n\t *\r\n\t * @protected\r\n\t *\r\n\t * @param {String} method The name of the method to invoke\r\n\t * @param {Object} params Named params to pass to the method\r\n\t * @param {Function} [callback] The success callback handler\r\n\t * @param {Error} callback.error Any error that may have occurred\r\n\t * @param {Boolean} callback.success\r\n\t * @param {Boolean} [isNotification=false] If true the message will have no id and no response handler will be stored\r\n\t * @param {ArrayBuffer|Blob} [payload] Any binary data to send along with the message\r\n\t *\r\n\t */\r\n\tChannel.prototype.invoke = function(method, params, callback, isNotification, payload){\r\n\t\r\n\t    logger.debug('channel.invoke',arguments);\r\n\t\r\n\t    if(!types.isString(method))throw new TypeError('method must be a valid string');\r\n\t\r\n\t    params = params || {};\r\n\t\r\n\t    var msg = {\r\n\t        method  : method,\r\n\t        params  : params\r\n\t    };\r\n\t\r\n\t    if(callback && !isNotification){\r\n\t        msg.id = Date.now();\r\n\t        this.resultHandlers[msg.id] = callback;\r\n\t    }\r\n\t\r\n\t    if(payload){\r\n\t        msg = Channel.packMessage(msg,payload);\r\n\t    }else{\r\n\t        msg = JSON.stringify(msg);\r\n\t    }\r\n\t\r\n\t    this.connection.send(msg);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Fired when a channel makes a connection\r\n\t *\r\n\t * @event Channel#connect\r\n\t * @param {Client} client - Your client\r\n\t * @example\r\n\t * channel.on('connect',function(client){\r\n\t *  console.log('You are now connected');\r\n\t * });\r\n\t */\r\n\tChannel.prototype._onConnect = function(data) {\r\n\t\r\n\t    logger.silly('channel._onConnect');\r\n\t\r\n\t    this.connected = true;\r\n\t\r\n\t    // Store my id\r\n\t    this.clientId = data.id;\r\n\t\r\n\t    // Store the current connected client\r\n\t    data.clients.forEach(function(clientInfo){\r\n\t\r\n\t        // Create a client and add to our list\r\n\t        var client = new Client(clientInfo.id, clientInfo.attributes, clientInfo.isHost);\r\n\t        this.clients.push(client);\r\n\t\r\n\t    },this);\r\n\t\r\n\t    // call the connect callback if present and reset\r\n\t    if(this.connectCallback) {\r\n\t        logger.debug('channel.connect->callback',this.clients.me);\r\n\t        this.connectCallback(null, this.clients.me);\r\n\t        this.connectCallback = null;\r\n\t    }\r\n\t\r\n\t\r\n\t    logger.debug('channel.emit(\"connect\")',this.clients.me);\r\n\t    this.emit('connect',this.clients.me);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Fired when a channel disconnects\r\n\t *\r\n\t * @event Channel#disconnect\r\n\t * @param {Client} client - Your client\r\n\t * @example\r\n\t * channel.on('disconnect',function(client){\r\n\t *  console.log('You are now disconnected');\r\n\t * });\r\n\t */\r\n\tChannel.prototype._onDisconnect = function(data) {\r\n\t    logger.silly('channel._onDisconnect');\r\n\t\r\n\t    if(this.connected){\r\n\t        var client = this.clients.me;\r\n\t        this.clients.clear();\r\n\t\r\n\t        logger.debug('channel.emit(\"disconnect\")',client);\r\n\t        this.emit('disconnect',client);\r\n\t    }\r\n\t    this.connected = false;\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Fired when a peer client channel makes a connection\r\n\t *\r\n\t * @event Channel#clientConnect\r\n\t * @param {Client} client - The client that connected\r\n\t * @example\r\n\t * channel.on('clientConnect',function(client){\r\n\t *  console.log(client.id + 'is now connected');\r\n\t * });\r\n\t */\r\n\tChannel.prototype._onClientConnect = function(data) {\r\n\t    logger.silly('channel._onClientConnect');\r\n\t\r\n\t    var client = new Client(data.id, data.attributes, data.isHost);\r\n\t    this.clients.push(client);\r\n\t\r\n\t    logger.debug('channel.emit(\"clientConnect\")',client);\r\n\t    this.emit('clientConnect',client);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Fired when a peer client disconnects\r\n\t *\r\n\t * @event Channel#clientDisconnect\r\n\t * @param {Client} client - The client that connected\r\n\t * @example\r\n\t * channel.on('clientDisconnect',function(client){\r\n\t *  console.log(client.id + 'has disconnected');\r\n\t * });\r\n\t */\r\n\tChannel.prototype._onClientDisconnect = function(data) {\r\n\t    logger.silly('channel._onClientDisconnect');\r\n\t\r\n\t    var client = this.clients.getById(data.id);\r\n\t    if(client) this.clients.remove(client);\r\n\t    else {\r\n\t        logger.warn('client '+data.id+' could not be found, so it was not removed from the client list');\r\n\t        client = new Client(data.id, data.attributes, data.isHost);\r\n\t    }\r\n\t\r\n\t\r\n\t    logger.debug('channel.emit(\"clientDisconnect\")',client);\r\n\t    this.emit('clientDisconnect',client);\r\n\t\r\n\t};\r\n\t\r\n\t/***\r\n\t * Fired when the host has connected and is ready to accept messages\r\n\t * @deprecated since version 2.0.18 (please use the connect event)\r\n\t *\r\n\t * @event Channel#ready\r\n\t */\r\n\tChannel.prototype._onReady = function(data){\r\n\t\r\n\t    logger.debug('channel.emit(\"ready\")');\r\n\t    this.emit('ready');\r\n\t};\r\n\t\r\n\tChannel.prototype._onUserEvent = function(msg){\r\n\t\r\n\t    var client = this.clients.getById(msg.from);\r\n\t    var event = msg.event;\r\n\t    var data  = msg.data;\r\n\t    var payload = msg.payload;\r\n\t\r\n\t    logger.debug('channel.emit(\"'+event+'\")',data, client, payload);\r\n\t    this.emit(event, data, client, payload);\r\n\t};\r\n\t\r\n\tChannel.prototype._onSocketOpen = function() {\r\n\t    logger.silly('channel._onSocketOpen');\r\n\t};\r\n\t\r\n\tChannel.prototype._onSocketClose = function() {\r\n\t    logger.silly('channel._onSocketClose');\r\n\t    this._onDisconnect();\r\n\t};\r\n\t\r\n\tChannel.prototype._onSocketError = function(e) {\r\n\t    logger.silly('channel._onSocketError',e);\r\n\t    this.emit('error', new Error(\"WebSocket error\"));\r\n\t};\r\n\t\r\n\t\r\n\tChannel.prototype._onSocketMessage = function(msg){\r\n\t\r\n\t    logger.silly('channel._onSocketMessage',msg);\r\n\t\r\n\t    // Serialize the message\r\n\t    try{\r\n\t        if(typeof msg.data === \"string\"){\r\n\t            msg = JSON.parse(msg.data);\r\n\t        }else{\r\n\t            var unpacked = Channel.unpackMessage(msg.data);\r\n\t            msg = unpacked.message;\r\n\t            msg.payload = unpacked.payload;\r\n\t        }\r\n\t    } catch (e) {\r\n\t        logger.warn('unable to parse message', msg);\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    // RPC Response?\r\n\t    if(msg.id && (msg.result || msg.error)){\r\n\t\r\n\t        if(!this.resultHandlers[msg.id]){\r\n\t            logger.warn('unable to find result handler for result message ', msg);\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        this.resultHandlers[msg.id](msg.error,msg.result);\r\n\t\r\n\t    }\r\n\t    // Event?\r\n\t    else if (msg.event){\r\n\t\r\n\t        switch(msg.event){\r\n\t\r\n\t            case 'ms.channel.connect' :\r\n\t                this._onConnect(msg.data);\r\n\t                break;\r\n\t\r\n\t            case 'ms.channel.clientConnect' :\r\n\t                this._onClientConnect(msg.data);\r\n\t                break;\r\n\t\r\n\t            case 'ms.channel.clientDisconnect' :\r\n\t                this._onClientDisconnect(msg.data);\r\n\t                break;\r\n\t\r\n\t            case 'ms.channel.ready' :\r\n\t                this._onReady(msg.data);\r\n\t                break;\r\n\t\r\n\t            default :\r\n\t                this._onUserEvent(msg);\r\n\t                break;\r\n\t        }\r\n\t    }\r\n\t    // Unrecognized\r\n\t    else{\r\n\t        logger.warn('unrecognized message type', msg);\r\n\t    }\r\n\t\r\n\t};\r\n\t\r\n\tChannel.prototype.startHealthCheck = function(){\r\n\t\r\n\t    // stop any previous health checking\r\n\t    this.stopHealthCheck();\r\n\t\r\n\t    if(this.pingTimeout > 0){\r\n\t\r\n\t        var lastReceivedPing = null;\r\n\t\r\n\t        this.on(EVENT_HEALTH_CHECK, function(sent){\r\n\t            lastReceivedPing = Date.now();\r\n\t            logger.debug('ping trip : ',lastReceivedPing - sent);\r\n\t            logger.debug('updated last ping time : ',lastReceivedPing);\r\n\t        });\r\n\t\r\n\t        var checkAndPing = function(){\r\n\t\r\n\t            var now = Date.now();\r\n\t            if(!lastReceivedPing) lastReceivedPing = now;\r\n\t\r\n\t            if(now - lastReceivedPing < this.pingTimeout){\r\n\t                logger.debug('sending ping');\r\n\t                this.publish(EVENT_HEALTH_CHECK, now, this.clients.me.id);\r\n\t            }else{\r\n\t                logger.debug('ping timed, out closing connection');\r\n\t                this.stopHealthCheck();\r\n\t                if(this.connection){\r\n\t                    this.connection.close();\r\n\t                    // forcing disconnect\r\n\t                    this._onDisconnect();\r\n\t                }\r\n\t            }\r\n\t        }.bind(this);\r\n\t\r\n\t        // start the timer\r\n\t        this.pingInterval = setInterval(checkAndPing,this.pingTimeout);\r\n\t    }\r\n\t\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tChannel.prototype.stopHealthCheck = function(){\r\n\t    clearInterval(this.pingInterval);\r\n\t    this.removeAllListeners(EVENT_HEALTH_CHECK);\r\n\t};\r\n\t\r\n\t\r\n\tmodule.exports = Channel;\r\n\t\r\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar levels = ['error','warn','info','verbose','debug','silly'];\r\n\t\r\n\tvar logger = {\r\n\t\r\n\t    level : 'disabled',\r\n\t\r\n\t    log : function(level /* ,....args*/){\r\n\t        if(logger.level !== 'disabled' && (levels.indexOf(level) <= levels.indexOf(logger.level))){\r\n\t            var args = Array.prototype.slice.call(arguments,1);\r\n\t            args.unshift('[MSF:'+level.toUpperCase()+']');\r\n\t            if(console[level]){\r\n\t                console[level].apply(console,args);\r\n\t            }else{\r\n\t                console.log.apply(console,args);\r\n\t            }\r\n\t\r\n\t        }\r\n\t    }\r\n\t\r\n\t};\r\n\t\r\n\tfunction createLevel(level){\r\n\t    return function(/*args*/){\r\n\t        var args = Array.prototype.slice.call(arguments);\r\n\t        args.unshift(level);\r\n\t        logger.log.apply(logger,args);\r\n\t    };\r\n\t}\r\n\t\r\n\t// Create logger methods based on levels\r\n\tfor(var i=0; i<levels.length; i++){\r\n\t    var level = levels[i];\r\n\t    logger[level] = createLevel(level);\r\n\t}\r\n\t\r\n\tmodule.exports = logger;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar queryString = __webpack_require__(13);\r\n\t\r\n\tvar url = {\r\n\t\r\n\t    isValid : function(u){\r\n\t\r\n\t        var pattern = /^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;\r\n\t        return u.match(pattern) ? true : false;\r\n\t    },\r\n\t\r\n\t    parse : function(u){\r\n\t\r\n\t        var oUrl = {};\r\n\t        var parser = document.createElement('a');\r\n\t        parser.href = u; // \"http://example.com:3000/pathname/?search=test#hash\";\r\n\t\r\n\t        oUrl.href = parser.href; // => \"http://ip:port/path/page?query=string#hash\"\r\n\t        oUrl.protocol = parser.protocol; // => \"http:\"\r\n\t        oUrl.hostname = parser.hostname; // => \"example.com\"\r\n\t        oUrl.port = parser.port;     // => \"3000\"\r\n\t        oUrl.pathname = parser.pathname; // => \"/pathname/\"\r\n\t        oUrl.search = parser.search;   // => \"?search=test\"\r\n\t        oUrl.hash = parser.hash;     // => \"#hash\"\r\n\t        oUrl.host = parser.host;     // => \"example.com:3000\"\r\n\t        oUrl.queryString = queryString.parse(parser.search);\r\n\t\r\n\t        return oUrl;\r\n\t    }\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tmodule.exports = url;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tif (typeof Object.create === 'function') {\r\n\t    // implementation from standard node.js 'util' module\r\n\t    module.exports = function inherits(ctor, superCtor) {\r\n\t        ctor.super_ = superCtor;\r\n\t        ctor.prototype = Object.create(superCtor.prototype, {\r\n\t            constructor: {\r\n\t                value: ctor,\r\n\t                enumerable: false,\r\n\t                writable: true,\r\n\t                configurable: true\r\n\t            }\r\n\t        });\r\n\t    };\r\n\t} else {\r\n\t    // old school shim for old browsers\r\n\t    module.exports = function inherits(ctor, superCtor) {\r\n\t        ctor.super_ = superCtor;\r\n\t        var TempCtor = function () {};\r\n\t        TempCtor.prototype = superCtor.prototype;\r\n\t        ctor.prototype = new TempCtor();\r\n\t        ctor.prototype.constructor = ctor;\r\n\t    };\r\n\t}\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tfunction createDescriptor(e,c,w,v){\r\n\t    return {\r\n\t        enumerable : e,\r\n\t        configurable : c,\r\n\t        writable : w,\r\n\t        value : v\r\n\t    };\r\n\t}\r\n\t\r\n\tmodule.exports = {\r\n\t\r\n\t    readOnly : function(obj, key){\r\n\t\r\n\t        if(Array.isArray(key)){\r\n\t            key.forEach(function(k){\r\n\t                Object.defineProperty(obj, k, createDescriptor(true,true,false,obj[k]));\r\n\t            });\r\n\t        }else{\r\n\t            Object.defineProperty(obj, key, createDescriptor(true,true,false,obj[key]));\r\n\t        }\r\n\t\r\n\t    },\r\n\t\r\n\t    private : function(obj, key){\r\n\t\r\n\t        if(Array.isArray(key)){\r\n\t            key.forEach(function(k){ Object.defineProperty(obj, k, createDescriptor(false,true,true,obj[k])); });\r\n\t        }else{\r\n\t            Object.defineProperty(obj, key, createDescriptor(false,true,true,obj[key]));\r\n\t        }\r\n\t    }\r\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tmodule.exports = {\r\n\t\r\n\t    isString : function(obj){\r\n\t        return typeof obj === 'string';\r\n\t    },\r\n\t\r\n\t    isNull : function(obj){\r\n\t        return obj === null;\r\n\t    },\r\n\t\r\n\t    isBoolean : function(obj){\r\n\t        return typeof obj === 'boolean';\r\n\t    },\r\n\t\r\n\t    isNumber : function(obj){\r\n\t        return typeof obj === 'number';\r\n\t    },\r\n\t\r\n\t    isObject : function(obj){\r\n\t        return obj === Object(obj);\r\n\t    },\r\n\t\r\n\t    isArray : function(obj){\r\n\t        return obj.constructor === Array;\r\n\t    },\r\n\t\r\n\t    isFunction : function(obj){\r\n\t        return typeof obj === 'function';\r\n\t    },\r\n\t\r\n\t    isUndefined : function(obj){\r\n\t        return typeof obj === 'undefined';\r\n\t    }\r\n\t\r\n\t\r\n\t\r\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\r\n\t\r\n\t/*\r\n\t    Derived work from Sidre Sorhus (https://github.com/sindresorhus/query-string)\r\n\t */\r\n\t\r\n\t/*!\r\n\t query-string\r\n\t Parse and stringify URL query strings\r\n\t https://github.com/sindresorhus/query-string\r\n\t by Sindre Sorhus\r\n\t MIT License\r\n\t */\r\n\t\r\n\tvar queryString = {};\r\n\t\r\n\tqueryString.parse = function (str) {\r\n\t    if (typeof str !== 'string') {\r\n\t        return {};\r\n\t    }\r\n\t\r\n\t    str = str.trim().replace(/^(\\?|#)/, '');\r\n\t\r\n\t    if (!str) {\r\n\t        return {};\r\n\t    }\r\n\t\r\n\t    return str.trim().split('&').reduce(function (ret, param) {\r\n\t        var parts = param.replace(/\\+/g, ' ').split('=');\r\n\t        var key = parts[0];\r\n\t        var val = parts[1];\r\n\t\r\n\t        key = decodeURIComponent(key);\r\n\t        // missing `=` should be `null`:\r\n\t        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\r\n\t        val = val === undefined ? null : decodeURIComponent(val);\r\n\t\r\n\t        if (!ret.hasOwnProperty(key)) {\r\n\t            ret[key] = val;\r\n\t        } else if (Array.isArray(ret[key])) {\r\n\t            ret[key].push(val);\r\n\t        } else {\r\n\t            ret[key] = [ret[key], val];\r\n\t        }\r\n\t\r\n\t        return ret;\r\n\t    }, {});\r\n\t};\r\n\t\r\n\tqueryString.stringify = function (obj) {\r\n\t    return obj ? Object.keys(obj).map(function (key) {\r\n\t        var val = obj[key];\r\n\t\r\n\t        if (Array.isArray(val)) {\r\n\t            return val.map(function (val2) {\r\n\t                return encodeURIComponent(key) + '=' + encodeURIComponent(val2);\r\n\t            }).join('&');\r\n\t        }\r\n\t\r\n\t        return encodeURIComponent(key) + '=' + encodeURIComponent(val);\r\n\t    }).join('&') : '';\r\n\t};\r\n\t\r\n\tmodule.exports = queryString;\r\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar types = util.types;\r\n\t\r\n\t\r\n\t/**\r\n\t * A representation of an individual device or user connected to a channel.\r\n\t * Clients can have user defined attributes that are readable by all other clients.\r\n\t * @class Client\r\n\t *\r\n\t * @hide-constructor\r\n\t *\r\n\t */\r\n\tfunction Client(id, attributes, isHost, connectTime){\r\n\t\r\n\t    if(!types.isString(id)) throw new TypeError('id must be a valid string');\r\n\t    if(attributes && !types.isObject(attributes)) throw new TypeError('attributes must be a valid object');\r\n\t\r\n\t    /**\r\n\t     * The id of the client\r\n\t     *\r\n\t     * @name id\r\n\t     * @memberOf Client.prototype\r\n\t     * @type {String}\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.id = id;\r\n\t\r\n\t    /**\r\n\t     * A map of attributes passed by the client when connecting\r\n\t     *\r\n\t     * @name attributes\r\n\t     * @memberOf Client.prototype\r\n\t     * @type {Object}\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.attributes = attributes || {};\r\n\t\r\n\t    /**\r\n\t     * Flag for determining if the client is the host\r\n\t     *\r\n\t     * @name isHost\r\n\t     * @memberOf Client.prototype\r\n\t     * @type {Boolean}\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.isHost = isHost;\r\n\t\r\n\t    /**\r\n\t     * The time which the client connected in epoch milliseconds\r\n\t     *\r\n\t     * @name connectTime\r\n\t     * @memberOf Client.prototype\r\n\t     * @type {Number}\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.connectTime = connectTime || Date.now();\r\n\t\r\n\t    Object.freeze(this.attributes);\r\n\t    Object.freeze(this);\r\n\t\r\n\t}\r\n\t\r\n\tmodule.exports = Client;\r\n\t\r\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar types = util.types;\r\n\t\r\n\t/**\r\n\t * A list of {@link Client|clients} accessible through {@link Channel#clients|channel.clients}.\r\n\t * This list is managed by the channel and automatically adds and removes clients as they connect and disconnect\r\n\t * @class ClientList\r\n\t * @extends Array\r\n\t * @hide-constructor\r\n\t */\r\n\t\r\n\tfunction ClientList(channel){\r\n\t\r\n\t    if(!types.isObject(channel))throw new TypeError('channel must be of type Channel');\r\n\t\r\n\t    this.channel = channel;\r\n\t\r\n\t    ClientList.super_.call(this);\r\n\t\r\n\t}\r\n\t\r\n\tutil.inherits(ClientList, Array);\r\n\t\r\n\t/**\r\n\t * A reference to your client\r\n\t *\r\n\t * @member {Client} ClientList#me\r\n\t * @readonly\r\n\t */\r\n\tObject.defineProperty(ClientList.prototype, 'me', {\r\n\t    get : function(){\r\n\t        return this.getById(this.channel.clientId);\r\n\t    }\r\n\t});\r\n\t\r\n\t/***\r\n\t * Clears the list\r\n\t * @protected\r\n\t */\r\n\tClientList.prototype.clear = function(){\r\n\t    this.length = 0;\r\n\t};\r\n\t\r\n\t/***\r\n\t * Removes an client from the list\r\n\t * @protected\r\n\t */\r\n\tClientList.prototype.remove = function(item){\r\n\t    var i = this.indexOf(item);\r\n\t    if(i !== -1) {\r\n\t        this.splice(i, 1);\r\n\t        return item;\r\n\t    }\r\n\t    return null;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Returns a client by id\r\n\t *\r\n\t * @param {String} id The client\r\n\t * @return {Client}\r\n\t *\r\n\t */\r\n\tClientList.prototype.getById = function(id){\r\n\t\r\n\t    if(!types.isString(id) && !types.isNumber(id)) throw new TypeError('id must be a valid string or number');\r\n\t    for(var i=0; i<this.length; i++){\r\n\t        if(this[i].id === id) return this[i];\r\n\t    }\r\n\t    return null;\r\n\t};\r\n\t\r\n\t\r\n\tmodule.exports = ClientList;\r\n\t\r\n\n\n/***/ }\n/******/ ])\n\n\n/** WEBPACK FOOTER **\n ** msf-2.0.21.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 48521ae112f76c1a9608\n **/","\"use strict\";\r\n\r\nvar msf = require('./lib/msf');\r\n\r\nmsf.version = '{{version}}';\r\n\r\nif (typeof define === 'function' && define.amd) {\r\n    define(function() { return msf; });\r\n} else if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = msf;\r\n} else {\r\n    window.msf = msf;\r\n}\r\n\r\nmodule.exports = msf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar EventEmitter = require('./EventEmitter');\r\nvar Service = require('./Service');\r\nvar Search = require('./Search');\r\n\r\n// We will use a singleton for search so that we don't create multiple frames in the page\r\nvar search = null;\r\n\r\n\r\n/**\r\n * The 'msf' module/object is the entry point for the API.\r\n * If including the library via script tag it will be a global object attached to the window\r\n * or the export of the module if using amd/commonjs (requirejs/browserify)\r\n *\r\n * @module msf\r\n *\r\n */\r\n\r\n\r\n/*\r\n Can be used to debug if there is an issue\r\n msf.logger.level = 'error'|'warn'|'info'|'verbose'|'debug'|'silly'\r\n */\r\nmodule.exports.logger  = util.logger;\r\n\r\n\r\n/**\r\n * Searches the local network for compatible multiscreen services\r\n *\r\n * @param {Function} [callback] If a callback is passed the search is immediately started.\r\n * @param {Error} callback.err The callback handler\r\n * @param {Service[]} callback.result An array of {@link Service} instances found on the network\r\n * @returns {Search} A search instance (a singleton is used to reduce page resources)\r\n *\r\n * @example\r\n * msf.search(function(err, services){\r\n *   if(err) return console.error('something went wrong', err.message);\r\n *   console.log('found '+services.length+' services');\r\n * }\r\n *\r\n * // OR\r\n *\r\n * var search = msf.search();\r\n * search.on('found', function(service){\r\n *    console.log('found service '+service.name);\r\n * }\r\n * search.start();\r\n *\r\n */\r\nmodule.exports.search = function(callback){\r\n\r\n    // Create the single instance if we don't already have one\r\n    if(!search) search = new Search();\r\n\r\n    // If there is a callback defined, listen once for results and start the search\r\n    if(callback) {\r\n        search.once('found',function(services){\r\n            callback(null, services);\r\n        });\r\n\r\n        // start on next tick to support search callbacks and events\r\n        setTimeout(function(){ search.start(); },0);\r\n\r\n    }\r\n\r\n    return search;\r\n\r\n};\r\n\r\n\r\n/**\r\n * Retrieves a reference to the service running on the current device. This is typically only used on the 'host' device.\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Error} callback.error\r\n * @param {Service} callback.service The service instance\r\n *\r\n * @example\r\n * msf.local(function(err, service){\r\n *   console.log('my service name is '+service.name);\r\n * }\r\n */\r\nmodule.exports.local = function(callback){\r\n\r\n    Service.getLocal(callback);\r\n\r\n};\r\n\r\n/**\r\n * Retrieves a service instance by it's uri\r\n *\r\n * @param {String} uri The uri of the service (http://host:port/api/v2/)\r\n * @param {Function} callback The callback handler\r\n * @param {Error} callback.error\r\n * @param {Service} callback.service The service instance\r\n *\r\n * @example\r\n * msf.remote('http://host:port/api/v2/',function(err, service){\r\n *   console.log('the service name is '+service.name);\r\n * }\r\n */\r\nmodule.exports.remote = function(uri, callback){\r\n\r\n    Service.getByURI(uri, callback);\r\n\r\n};\r\n\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/msf.js\n ** module id = 1\n ** module chunks = 0\n **/","/* jshint newcap: false, -W040: false, -W004: false, -W003 : false */\r\n\"use strict\";\r\n\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n/**\r\n * All objects which emit events are instances of EventEmitter.\r\n * The EventEmitter class is derived from the nodejs EventEmitter.\r\n *\r\n * For simplicity only the most used members are documented here, for full documentation read {@link http://nodejs.org/api/events.html}\r\n * @class EventEmitter\r\n * @hide-constructor\r\n */\r\nfunction EventEmitter() {\r\n this._events = this._events || {};\r\n this._maxListeners = this._maxListeners || undefined;\r\n}\r\nmodule.exports = EventEmitter;\r\n\r\n// Backwards-compat with node 0.10.x\r\nEventEmitter.EventEmitter = EventEmitter;\r\n\r\nEventEmitter.prototype._disabledEvents = {};\r\nEventEmitter.prototype._events = undefined;\r\nEventEmitter.prototype._maxListeners = undefined;\r\n\r\n// By default EventEmitters will print a warning if more than 10 listeners are\r\n// added to it. This is a useful default which helps finding memory leaks.\r\nEventEmitter.defaultMaxListeners = 10;\r\n\r\n// Obviously not all Emitters should be limited to 10. This function allows\r\n// that to be increased. Set to zero for unlimited.\r\nEventEmitter.prototype.setMaxListeners = function(n) {\r\n if (!isNumber(n) || n < 0 || isNaN(n))\r\n  throw TypeError('n must be a positive number');\r\n this._maxListeners = n;\r\n return this;\r\n};\r\n\r\nEventEmitter.prototype.emit = function(type) {\r\n var er, handler, len, args, i, listeners;\r\n\r\n if (!this._events){\r\n     this._events = {};\r\n }\r\n\r\n if(this._disabledEvents[type]) return false;\r\n\r\n // If there is no 'error' event listener then throw.\r\n if (type === 'error') {\r\n  if (!this._events.error ||\r\n      (isObject(this._events.error) && !this._events.error.length)) {\r\n   er = arguments[1];\r\n   if (er instanceof Error) {\r\n    throw er; // Unhandled 'error' event\r\n   }\r\n   throw TypeError('Uncaught, unspecified \"error\" event.');\r\n  }\r\n }\r\n\r\n handler = this._events[type];\r\n\r\n if (isUndefined(handler))\r\n  return false;\r\n\r\n if (isFunction(handler)) {\r\n  switch (arguments.length) {\r\n   // fast cases\r\n   case 1:\r\n    handler.call(this);\r\n    break;\r\n   case 2:\r\n    handler.call(this, arguments[1]);\r\n    break;\r\n   case 3:\r\n    handler.call(this, arguments[1], arguments[2]);\r\n    break;\r\n   // slower\r\n   default:\r\n    len = arguments.length;\r\n    args = new Array(len - 1);\r\n    for (i = 1; i < len; i++)\r\n     args[i - 1] = arguments[i];\r\n    handler.apply(this, args);\r\n  }\r\n } else if (isObject(handler)) {\r\n  len = arguments.length;\r\n  args = new Array(len - 1);\r\n  for (i = 1; i < len; i++)\r\n   args[i - 1] = arguments[i];\r\n\r\n  listeners = handler.slice();\r\n  len = listeners.length;\r\n  for (i = 0; i < len; i++){\r\n      // a small hack put in to be able to stop event emission\r\n      var r = listeners[i].apply(this, args);\r\n      if(r === 'stopEvent') break;\r\n  }\r\n\r\n }\r\n\r\n return true;\r\n};\r\n\r\nEventEmitter.prototype.addListener = function(type, listener) {\r\n var m;\r\n\r\n if (!isFunction(listener))\r\n  throw TypeError('listener must be a function');\r\n\r\n if (!this._events)\r\n  this._events = {};\r\n\r\n // To avoid recursion in the case that type === \"newListener\"! Before\r\n // adding it to the listeners, first emit \"newListener\".\r\n if (this._events.newListener)\r\n  this.emit('newListener', type,\r\n      isFunction(listener.listener) ?\r\n          listener.listener : listener);\r\n\r\n if (!this._events[type])\r\n // Optimize the case of one listener. Don't need the extra array object.\r\n  this._events[type] = listener;\r\n else if (isObject(this._events[type]))\r\n // If we've already got an array, just append.\r\n  this._events[type].push(listener);\r\n else\r\n // Adding the second element, need to change to array.\r\n  this._events[type] = [this._events[type], listener];\r\n\r\n // Check for listener leak\r\n if (isObject(this._events[type]) && !this._events[type].warned) {\r\n  var m;\r\n  if (!isUndefined(this._maxListeners)) {\r\n   m = this._maxListeners;\r\n  } else {\r\n   m = EventEmitter.defaultMaxListeners;\r\n  }\r\n\r\n  if (m && m > 0 && this._events[type].length > m) {\r\n   this._events[type].warned = true;\r\n   console.error('(node) warning: possible EventEmitter memory ' +\r\n       'leak detected. %d listeners added. ' +\r\n       'Use emitter.setMaxListeners() to increase limit.',\r\n       this._events[type].length);\r\n   if (typeof console.trace === 'function') {\r\n    // not supported in IE 10\r\n    console.trace();\r\n   }\r\n  }\r\n }\r\n\r\n return this;\r\n};\r\n\r\n/**\r\n * Adds a listener for the event.\r\n * @param {String} type The event name to listen to\r\n * @param {Function} listener The function to invoke when the event occurs\r\n * @returns EventEmitter\r\n *\r\n */\r\nEventEmitter.prototype.on = function(type, listener){\r\n    EventEmitter.prototype.addListener.apply(this,arguments);\r\n};\r\n\r\n/**\r\n * Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed.\r\n * @param {String} type The event name to listen to\r\n * @param {Function} listener The function to invoke when the event occurs\r\n * @returns EventEmitter\r\n *\r\n */\r\nEventEmitter.prototype.once = function(type, listener) {\r\n if (!isFunction(listener))\r\n  throw TypeError('listener must be a function');\r\n\r\n var fired = false;\r\n\r\n function g() {\r\n  this.removeListener(type, g);\r\n\r\n  if (!fired) {\r\n   fired = true;\r\n   listener.apply(this, arguments);\r\n  }\r\n }\r\n\r\n g.listener = listener;\r\n this.on(type, g);\r\n\r\n return this;\r\n};\r\n\r\n// emits a 'removeListener' event iff the listener was removed\r\nEventEmitter.prototype.removeListener = function(type, listener) {\r\n var list, position, length, i;\r\n\r\n if (!isFunction(listener))\r\n  throw TypeError('listener must be a function');\r\n\r\n if (!this._events || !this._events[type])\r\n  return this;\r\n\r\n list = this._events[type];\r\n length = list.length;\r\n position = -1;\r\n\r\n if (list === listener ||\r\n     (isFunction(list.listener) && list.listener === listener)) {\r\n  delete this._events[type];\r\n  if (this._events.removeListener)\r\n   this.emit('removeListener', type, listener);\r\n\r\n } else if (isObject(list)) {\r\n  for (i = length; i-- > 0;) {\r\n   if (list[i] === listener ||\r\n       (list[i].listener && list[i].listener === listener)) {\r\n    position = i;\r\n    break;\r\n   }\r\n  }\r\n\r\n  if (position < 0)\r\n   return this;\r\n\r\n  if (list.length === 1) {\r\n   list.length = 0;\r\n   delete this._events[type];\r\n  } else {\r\n   list.splice(position, 1);\r\n  }\r\n\r\n  if (this._events.removeListener)\r\n   this.emit('removeListener', type, listener);\r\n }\r\n\r\n return this;\r\n};\r\n\r\n/**\r\n * Alias for removeListener\r\n * @param {String} type The event name to stop listening to\r\n * @param {Function} listener The function that was originally add to handle the event\r\n * @returns EventEmitter\r\n *\r\n */\r\nEventEmitter.prototype.off = function(type, listener){\r\n    EventEmitter.prototype.removeListener.apply(this,arguments);\r\n};\r\n\r\n\r\n/**\r\n * Removes all listeners, or those of the specified event.\r\n * @param {String} event The event name to stop listening to\r\n * @returns EventEmitter\r\n *\r\n */\r\nEventEmitter.prototype.removeAllListeners = function(type) {\r\n var key, listeners;\r\n\r\n if (!this._events)\r\n  return this;\r\n\r\n // not listening for removeListener, no need to emit\r\n if (!this._events.removeListener) {\r\n  if (arguments.length === 0)\r\n   this._events = {};\r\n  else if (this._events[type])\r\n   delete this._events[type];\r\n  return this;\r\n }\r\n\r\n // emit removeListener for all listeners on all events\r\n if (arguments.length === 0) {\r\n  for (key in this._events) {\r\n   if (key === 'removeListener') continue;\r\n   this.removeAllListeners(key);\r\n  }\r\n  this.removeAllListeners('removeListener');\r\n  this._events = {};\r\n  return this;\r\n }\r\n\r\n listeners = this._events[type];\r\n\r\n if (isFunction(listeners)) {\r\n  this.removeListener(type, listeners);\r\n } else {\r\n  // LIFO order\r\n  while (listeners.length)\r\n   this.removeListener(type, listeners[listeners.length - 1]);\r\n }\r\n delete this._events[type];\r\n\r\n return this;\r\n};\r\n\r\nEventEmitter.prototype.listeners = function(type) {\r\n var ret;\r\n if (!this._events || !this._events[type])\r\n  ret = [];\r\n else if (isFunction(this._events[type]))\r\n  ret = [this._events[type]];\r\n else\r\n  ret = this._events[type].slice();\r\n return ret;\r\n};\r\n\r\nEventEmitter.prototype.disableEvent = function(type) {\r\n    if(type && typeof type === 'string'){\r\n        this._disabledEvents[type] = true;\r\n    }\r\n};\r\n\r\nEventEmitter.prototype.enableEvent = function(type) {\r\n    if(type && typeof type === 'string'){\r\n        delete this._disabledEvents[type];\r\n    }\r\n};\r\n\r\nEventEmitter.listenerCount = function(emitter, type) {\r\n var ret;\r\n if (!emitter._events || !emitter._events[type])\r\n  ret = 0;\r\n else if (isFunction(emitter._events[type]))\r\n  ret = 1;\r\n else\r\n  ret = emitter._events[type].length;\r\n return ret;\r\n};\r\n\r\nfunction isFunction(arg) {\r\n return typeof arg === 'function';\r\n}\r\n\r\nfunction isNumber(arg) {\r\n return typeof arg === 'number';\r\n}\r\n\r\nfunction isObject(arg) {\r\n return typeof arg === 'object' && arg !== null;\r\n}\r\n\r\nfunction isUndefined(arg) {\r\n return arg === void 0;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/EventEmitter.js\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar props = util.props;\r\nvar Application = require('./Application');\r\nvar Channel = require('./Channel');\r\n\r\n\r\n/**\r\n * A Service instance represents the multiscreen service running on the remote device, such as a SmartTV\r\n *\r\n * @class Service\r\n * @hide-constructor\r\n *\r\n */\r\n\r\nfunction Service(description){\r\n\r\n    /**\r\n     * The id of the service\r\n     *\r\n     * @member {String} Service#id\r\n     * @readonly\r\n     */\r\n    this.id = description.id;\r\n\r\n    /**\r\n     * The name of the service (Living Room TV)\r\n     *\r\n     * @member {String} Service#name\r\n     * @readonly\r\n     */\r\n    this.name = description.name;\r\n\r\n    /**\r\n     * The version of the service (x.x.x)\r\n     *\r\n     * @member {String} Service#version\r\n     * @readonly\r\n     */\r\n    this.version = description.version;\r\n\r\n    /**\r\n     * The type of the service (Samsung SmartTV)\r\n     *\r\n     * @member {String} Service#type\r\n     * @readonly\r\n     */\r\n    this.type = description.type;\r\n\r\n    /**\r\n     * The uri of the service (http://<ip>:<port>/api/v2/)\r\n     *\r\n     * @member {String} Service#uri\r\n     * @readonly\r\n     */\r\n    this.uri = description.uri;\r\n\r\n    /**\r\n     * A hash of additional information about the device the service is running on\r\n     *\r\n     * @member {String} Service#device\r\n     * @readonly\r\n     */\r\n    this.device = description.device;\r\n\r\n    props.readOnly(this,['id','name','version','type','uri','device']);\r\n\r\n}\r\n\r\n/**\r\n * Creates {@link Application} instances belonging to that service\r\n *\r\n * @param {String} id An installed application id or url of the web application\r\n * @param {String} channelUri The URI of the channel to connect to.\r\n * @returns {Application}\r\n *\r\n * @example\r\n var application = service.application('http://mydomain/myapp/', 'com.mydomain.myapp');\r\n */\r\nService.prototype.application = function(id, channelUri){\r\n\r\n    return new Application(this, id, channelUri);\r\n\r\n};\r\n\r\n/**\r\n * creates a channel of the service ('mychannel')\r\n *\r\n * @param {String} uri The uri of the Channel\r\n * @returns {Channel}\r\n *\r\n * @example\r\n var channel = service.channel('com.mydomain.myapp');\r\n */\r\nService.prototype.channel = function(uri){\r\n\r\n    return new Channel(this, uri);\r\n\r\n};\r\n\r\n\r\n/***\r\n * Retrieves a reference to the service running on the current device\r\n * (public api should use msf.local)\r\n *\r\n * @protected\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Error} callback.err The callback handler\r\n * @param {Service} callback.service The service instance\r\n *\r\n */\r\nService.getLocal = function(callback){\r\n\r\n    Service.getByURI('http://127.0.0.1:8001/api/v2/', callback);\r\n\r\n};\r\n\r\n/***\r\n * Retrieves a service instance by it's uri\r\n * (public api should use msf.remote)\r\n *\r\n * @protected\r\n *\r\n * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\r\n * @param {Function} callback The callback handler\r\n * @param {Error} callback.err The callback handler\r\n * @param {Service} callback.service The service instance\r\n *\r\n */\r\nService.getByURI = function(uri, callback){\r\n\r\n    var oReq = new XMLHttpRequest();\r\n    oReq.timeout = 5000;\r\n    oReq.ontimeout = function(){callback();};\r\n    oReq.onload = function() {\r\n\r\n        if(this.status === 200){\r\n            try{\r\n                var result = JSON.parse(this.responseText);\r\n                callback(null, new Service(result));\r\n            }catch(e){  callback(e); }\r\n        }else{\r\n            callback();\r\n        }\r\n    };\r\n    oReq.open(\"get\", uri, true);\r\n    oReq.send();\r\n\r\n};\r\n\r\n\r\nmodule.exports = Service;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Service.js\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar props = util.props;\r\nvar EventEmitter = require('./EventEmitter');\r\n\r\n\r\n/**\r\n * Provides members related to {@link Service} discovery.\r\n *\r\n * @class Search\r\n * @extends EventEmitter\r\n * @hide-constructor\r\n *\r\n */\r\n\r\nfunction Search(){\r\n\r\n\r\n    Search.super_.call(this);\r\n\r\n    this.discoveryFrame = null;\r\n    this.status = Search.STATUS_STOPPED;\r\n\r\n    var self = this;\r\n\r\n    /* Create the discovery iframe and load the search page */\r\n\r\n    var frame = document.createElement('iframe');\r\n    frame.setAttribute('width', '1');\r\n    frame.setAttribute('height', '1');\r\n    frame.style.display = \"none\";\r\n    frame.src = 'http://multiscreen.samsung.com/discoveryservice/v2/discover';\r\n    document.body.appendChild(frame);\r\n\r\n    /* Add a 'message' listener to the window that checks incoming messages */\r\n\r\n    this.windowMessageListener = function(event){\r\n\r\n        if(event.source === frame.contentWindow){\r\n\r\n            // ready message\r\n            if(event.data && event.data.event === 'discovery.ready'){\r\n                self.discoveryFrame = event.source;\r\n                self.onSearchReady();\r\n            }\r\n\r\n            // result message\r\n            else if(event.data && event.data.event === 'discovery.result'){\r\n                var results = [];\r\n                var Service = require('./Service');\r\n                for(var i=0; i<event.data.result.length; i++){\r\n                    results.push(new Service(event.data.result[i]));\r\n                }\r\n                self.onSearchResult(results);\r\n            }\r\n\r\n            // error message\r\n            else if(event.data && event.data.event === 'discovery.error'){\r\n                self.onSearchError(event.data.error);\r\n                this.status = Search.STATUS_STOPPED;\r\n            }\r\n        }\r\n    };\r\n    window.addEventListener('message', this.windowMessageListener);\r\n\r\n    props.private(this,['discoveryFrame','windowMessageListener']);\r\n\r\n}\r\n\r\nutil.inherits(Search, EventEmitter);\r\n\r\n\r\n/***\r\n * @constant {string}\r\n * @private\r\n */\r\nSearch.STATUS_STOPPED = 'stopped';\r\n\r\n/***\r\n * @constant {string}\r\n * @private\r\n */\r\nSearch.STATUS_STARTED = 'started';\r\n\r\n\r\n/**\r\n * Starts the search, looking for devices it can reach on the network\r\n * If a search is already in progress it will NOT begin a new search\r\n *\r\n * @example\r\n *\r\n * var search = msf.search();\r\n * search.on('found', function(service){\r\n *    console.log('found service '+service.name);\r\n * }\r\n * search.start();\r\n *\r\n */\r\nSearch.prototype.start = function(){\r\n    if(this.status === Search.STATUS_STOPPED){\r\n        if(this.discoveryFrame){\r\n            this.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\r\n        }else{\r\n            var self = this;\r\n            this.once('ready',function(){\r\n                self.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\r\n            });\r\n        }\r\n        this.onSearchStart();\r\n    }else{\r\n        console.warn('a previous search is already in progress');\r\n    }\r\n};\r\n\r\n/**\r\n * Stops the current search in progress (no 'found' events or search callbacks will fire)\r\n *\r\n * @example\r\n * search.stop();\r\n *\r\n */\r\nSearch.prototype.stop = function(){\r\n    this.onSearchStop();\r\n};\r\n\r\nSearch.prototype.onSearchReady = function(){\r\n    this.emit('ready');\r\n};\r\n\r\n\r\n/**\r\n * Fired when a search has discovered compatible services\r\n *\r\n * @event Search#found\r\n * @type {Array}\r\n * @example\r\n * search.on('found', function(service){\r\n *    console.log('found '+service.name);\r\n * });\r\n */\r\n\r\n\r\nSearch.prototype.onSearchResult = function(results){\r\n    if(this.status !== Search.STATUS_STOPPED){\r\n        this.emit('found',results);\r\n    }\r\n    this.status = Search.STATUS_STOPPED;\r\n};\r\n\r\n\r\n/**\r\n * Fired when a search error has occurred\r\n *\r\n * @event Search#error\r\n * @type {Error}\r\n * @example\r\n * search.on('error', function(err){\r\n *    console.error('something went wrong', err.message);\r\n * });\r\n */\r\n\r\nSearch.prototype.onSearchError = function(error){\r\n    this.emit('error',error);\r\n    this.status = Search.STATUS_STOPPED;\r\n};\r\n\r\n/**\r\n * Fired when a search has been started\r\n *\r\n * @event Search#start\r\n * @type {Search}\r\n *\r\n * @example\r\n * search.on('start', function(){\r\n *    ui.setState('searching');\r\n * });\r\n */\r\nSearch.prototype.onSearchStart = function(){\r\n    this.status = Search.STATUS_STARTED;\r\n    this.emit('start', this);\r\n};\r\n\r\n/**\r\n * Fired when a search has been stopped\r\n *\r\n * @event Search#stop\r\n * @type {Search}\r\n * @example\r\n * search.on('stop', function(){\r\n *    ui.setState('stopped');\r\n * });\r\n */\r\nSearch.prototype.onSearchStop = function(){\r\n    this.status = Search.STATUS_STOPPED;\r\n    this.emit('stop', this);\r\n};\r\n\r\n\r\nmodule.exports = Search;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Search.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = {\r\n\r\n    logger      : require('./logger'),\r\n    url         : require('./url'),\r\n    inherits    : require('./inherits'),\r\n    props       : require('./props'),\r\n    types       : require('./types'),\r\n    queryString : require('./querystring')\r\n\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/index.js\n ** module id = 5\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util    = require(\"./util\");\r\nvar logger  = util.logger;\r\nvar types   = util.types;\r\nvar props   = util.props;\r\nvar Channel = require('./Channel');\r\n\r\n\r\nvar TYPE_APP = 'applications';\r\nvar TYPE_WEB_APP = 'webapplication';\r\n\r\n\r\n/**\r\n * An Application represents an application on the remote device.\r\n * Use the class to control various aspects of the application such launching the app or getting information\r\n *\r\n * @class Application\r\n * @extends Channel\r\n *\r\n * @param {Service} service the underlying service\r\n * @param {String} id can be an installed app id or url for a webapp\r\n * @param {String} channelURI a unique channel id (com.myapp.mychannel)\r\n *\r\n * @hide-constructor\r\n */\r\n\r\nfunction Application(service, id, channelURI){\r\n\r\n    /* Type checking */\r\n    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\r\n    if(!types.isString(id)) throw new TypeError('id must be a valid string');\r\n    if(!types.isString(channelURI)) throw new TypeError('channelId must be a valid string');\r\n\r\n    /***\r\n     * The type of application (web application or installable app)\r\n     * @member {String} Application#type\r\n     * @private\r\n     */\r\n    this.type = id.match(/(file:\\/\\/|http(s)?:\\/\\/)/gmi) ? TYPE_WEB_APP : TYPE_APP;\r\n\r\n    /* Super Constructor */\r\n    Application.super_.call(this, service, channelURI);\r\n\r\n\r\n    /**\r\n     * The id of the application (this can be a url or installed application id)\r\n     * @member {String} Application#id\r\n     * @readonly\r\n     */\r\n    this.id = id;\r\n\r\n\r\n    /***\r\n     * The underlying of the application\r\n     * @member {String} Application#service\r\n     * @private\r\n     */\r\n    this.service = service;\r\n\r\n\r\n    /*\r\n    Listen for clientDisconnect events and disconnect if host disconnects\r\n    */\r\n    this.on('clientDisconnect', function(client){\r\n        if(client.isHost) this.disconnect();\r\n    }.bind(this));\r\n\r\n    /*\r\n     Turn off emitting the connect event from super as the application will provide its own\r\n    */\r\n    this.disableEvent('connect');\r\n\r\n\r\n    props.readOnly(this,'id');\r\n    props.private(this,'type','service');\r\n\r\n}\r\n\r\nutil.inherits(Application, Channel);\r\n\r\n\r\n\r\n/**\r\n * Starts and connects to the application on the remote device. Similar to the Channel 'connect' method but\r\n * within an Application the 'connect' callback and event will be only be called when the remote application has\r\n * launched and is ready to receive messages.\r\n *\r\n * @param {Object} attributes Any attributes to attach to your client\r\n * @param {Function} callback The callback handler\r\n * @param {Error} callback.error Any error that may have occurred during the connection or application startup\r\n * @param {Client} callback.client Your client object\r\n *\r\n * @example\r\n * app.connect({displayName:'Wheezy'},function(err, client){\r\n *   if(err) return console.error('something went wrong : ', error.code, error.message);\r\n *   console.info('You are now connected');\r\n * });\r\n */\r\nApplication.prototype.connect = function(attributes, callback){\r\n\r\n    if(!types.isObject(attributes)) throw new TypeError('attributes must be a valid object');\r\n    if(!types.isFunction(callback)) throw new TypeError('callback must be a valid function');\r\n\r\n    /*\r\n     This gets a little tricky because in an app instance we dont want connect to fire until the remote device is connected.\r\n     We also want to start the remote application and provide any errors from the launch\r\n     so we need to block the connect event from Channel, start the app, wait for the host to connect, have ready event (deprecated) trigger connect event.\r\n     */\r\n\r\n   this.start(function(err){\r\n\r\n       // If there was an issue starting the app callback with the error and stop execution\r\n       if(err) return callback(err);\r\n\r\n       // Call connect on the super\r\n       Channel.prototype.connect.call(this, attributes, function(err, client){\r\n\r\n           if(err) return callback(err);\r\n\r\n           // Set the connected flag to false until ready event fires\r\n           this.connected = false;\r\n\r\n           // Create a once listener for the ready event that will make the final callback and fire the connect event\r\n           var readyHandler = function(){\r\n\r\n               // Set the connected property\r\n               this.connected = true;\r\n\r\n               // call the connect callback\r\n               if(callback) {\r\n                   logger.debug('application.connect->callback', null, client);\r\n                   callback(null, client);\r\n               }\r\n\r\n               // enable the connect event, fire it, disable it again\r\n               logger.debug('application.emit(\"connect\")', client);\r\n               this.enableEvent('connect');\r\n               this.emit('connect',client);\r\n               this.disableEvent('connect');\r\n\r\n           }.bind(this);\r\n\r\n           // Listen once for the ready event\r\n           this.once('ready',readyHandler);\r\n\r\n       }.bind(this));\r\n\r\n   }.bind(this));\r\n\r\n};\r\n\r\n/**\r\n * Disconnects your client from the remote application.\r\n * If the first argument is an optional param and can be used close the remote application\r\n * The stop/exit command is only sent if you are the last connected client\r\n *\r\n * @param {Boolean} [exitOnRemote=true] Issues a stop/exit on the remote application before disconnecting\r\n * @param {Function} [callback] The callback handler\r\n * @param {Error} callback.error Any error that may have occurred during the connection or application startup\r\n * @param {Client} callback.client Your client object\r\n *\r\n * @example\r\n * app.disconnect(function(err){\r\n *     if(err) return console.error('something went wrong');\r\n *     console.info('You are now disconnected');\r\n * });\r\n */\r\nApplication.prototype.disconnect = function(exitOnRemote, callback){\r\n\r\n    if(types.isFunction(exitOnRemote)){\r\n        callback = exitOnRemote;\r\n        exitOnRemote = true;\r\n    }\r\n\r\n    if(types.isUndefined(exitOnRemote)) exitOnRemote = true;\r\n\r\n\r\n    if(exitOnRemote && this.clients.length <= 2) {\r\n\r\n        var stopCallback = function(err){\r\n            // still disconnect even if there was an error\r\n            Channel.prototype.disconnect.call(this, callback);\r\n        }.bind(this);\r\n\r\n        if(this.type === 'webapplication'){\r\n            this.invoke('ms.webapplication.stop', { url : this.id }, stopCallback);\r\n        }else{\r\n            this.invoke('ms.application.stop', { id : this.id }, stopCallback);\r\n        }\r\n\r\n    }else{\r\n        Channel.prototype.disconnect.call(this, callback);\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Installs the application on the remote device.\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Function} callback.err The callback handler\r\n *\r\n * @example\r\n *  app.connect({name:'Jason'}, function(err, client){\r\n *    if(err.code === 404){\r\n *      var install = confirm('Would you like to install the MyApp on your TV?');\r\n *      if(install){\r\n *         app.install(function(err){\r\n *            alert('Please follow the prompts on your TV to install the application');\r\n *         });\r\n *     }\r\n *   }\r\n *  });\r\n */\r\nApplication.prototype.install = function(callback){\r\n\r\n    if(this.type === TYPE_WEB_APP) return callback(new Error('web application cannot be installed'));\r\n\r\n    var e;\r\n    var req = new XMLHttpRequest();\r\n    req.timeout = 10000;\r\n\r\n    req.ontimeout = function(){\r\n        e = new Error('Request Timeout');\r\n        e.code = 408;\r\n        callback(e);\r\n    };\r\n\r\n    req.onload = function() {\r\n        if(this.status === 200){\r\n            callback(null, true);\r\n        }\r\n        else {\r\n            e = new Error(this.statusText);\r\n            e.code = this.status;\r\n            callback(e);\r\n        }\r\n    };\r\n\r\n    req.open(\"get\", this.service.uri + 'applications/'+this.id, true);\r\n    req.send();\r\n\r\n};\r\n\r\n\r\n/***\r\n * Starts the application on the remote device.\r\n *\r\n * @private\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Function} callback.err The callback handler\r\n *\r\n */\r\nApplication.prototype.start = function(callback){\r\n\r\n    var e;\r\n\r\n    var req = new XMLHttpRequest();\r\n    req.timeout = 10000;\r\n\r\n    req.ontimeout = function(){\r\n        e = new Error('Request Timeout');\r\n        e.code = 408;\r\n        callback(e);\r\n    };\r\n\r\n    req.onload = function() {\r\n        if(this.status === 200){\r\n            callback(null, true);\r\n        }\r\n        else {\r\n            e = new Error(this.statusText);\r\n            e.code = this.status;\r\n            callback(e);\r\n        }\r\n    };\r\n\r\n    if(this.type === TYPE_WEB_APP){\r\n        req.open(\"post\", this.service.uri + 'webapplication/', true);\r\n        req.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\r\n        req.send(JSON.stringify({url:this.id}));\r\n    }else{\r\n        req.open(\"post\", this.service.uri + 'applications/'+this.id, true);\r\n        req.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\r\n        req.send(JSON.stringify({}));\r\n    }\r\n\r\n\r\n};\r\n\r\n\r\n\r\nmodule.exports = Application;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Application.js\n ** module id = 6\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util    = require(\"./util\");\r\nvar logger  = util.logger;\r\nvar types   = util.types;\r\nvar props   = util.props;\r\nvar EventEmitter = require('./EventEmitter');\r\nvar Client = require('./Client');\r\nvar ClientList = require('./ClientList');\r\n\r\nvar EVENT_HEALTH_CHECK = '__ping';\r\n\r\n\r\n/**\r\n * A Channel is a discreet connection where multiple clients can communicate\r\n * @class Channel\r\n * @extends EventEmitter\r\n *\r\n * @hide-constructor\r\n */\r\nfunction Channel(service, uri){\r\n\r\n    logger.debug('new Channel',arguments);\r\n\r\n    /* Type checking */\r\n    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\r\n    if(!types.isString(uri)) throw new TypeError('uri must be a valid string');\r\n\r\n    /* Super Construction */\r\n    Channel.super_.call(this);\r\n\r\n    var self = this;\r\n    var oServiceUrl = util.url.parse(service.uri);\r\n\r\n\r\n    /***\r\n     * The connected state of the channel (a backing variable to isConnected)\r\n     * @protected\r\n     */\r\n    this.connected = false;\r\n\r\n    /***\r\n     * The id assigned to your client upon connection\r\n     * @private\r\n     */\r\n    this.clientId = null;\r\n\r\n    /***\r\n     * The underlying web socket connection\r\n     * @private\r\n     */\r\n    this.connection = null;\r\n\r\n    /***\r\n     * A map of message handler still waiting for responses\r\n     * @private\r\n     */\r\n    this.resultHandlers = {};\r\n\r\n    /***\r\n     * The url for the websocket to connect to\r\n     * @private\r\n     */\r\n    this.connectionUrl = 'ws://' + oServiceUrl.host + oServiceUrl.pathname + 'channels/' + uri;\r\n\r\n    /***\r\n     * The time in milliseconds between pings if a connection timeout is defined\r\n     * @private\r\n     */\r\n    this.pingTimeout = null;\r\n\r\n    /***\r\n     * The 'interval' reference set with setConnectionTimeout\r\n     * @private\r\n     */\r\n    this.pingInterval = null;\r\n\r\n\r\n    /**\r\n     * The collection of clients currently connected to the channel\r\n     *\r\n     * @member {ClientList} Channel#clients\r\n     * @readonly\r\n     *\r\n     */\r\n    this.clients = new ClientList(this);\r\n\r\n    /**\r\n     * The connection status of the channel\r\n     *\r\n     * @member {Boolean} Channel#isConnected\r\n     * @readonly\r\n     *\r\n     */\r\n    Object.defineProperty(this, 'isConnected', {\r\n        get : function(){\r\n            return self.connected;\r\n        }\r\n    });\r\n\r\n\r\n    /**\r\n     * Sets the connection timeout. When set the channel will utilize a connection health check while connected.\r\n     * If no pinging health check is not received within the given timeout the connection will close.\r\n     * To stop the health check set the timeout to 0\r\n     *\r\n     * @member {Boolean} Channel#connectionTimeout\r\n     *\r\n     * @example\r\n     * channel.connectionTimeout = 10000; // checks the connection every 10 seconds while connected\r\n     * channel.connectionTimeout = 0; // stops the health check\r\n     */\r\n    Object.defineProperty(this, 'connectionTimeout', {\r\n        set : function(timeout){\r\n            logger.debug('updating connection timeout ',timeout);\r\n            self.pingTimeout = timeout > 0 ? timeout : 0;\r\n            // If we are already connected start the check\r\n            if(this.isConnected) self.startHealthCheck();\r\n        },\r\n        get : function(){\r\n            return self.pingTimeout;\r\n        }\r\n    });\r\n\r\n\r\n\r\n    /* setup health check listeners */\r\n    this.on('connect', this.startHealthCheck);\r\n    this.on('disconnect', this.stopHealthCheck);\r\n\r\n\r\n    /* configure access and enumeration of properties */\r\n    props.readOnly(this, ['clients']);\r\n    props.private(this, [\r\n        'connected',\r\n        'clientId',\r\n        'connection',\r\n        'resultHandlers',\r\n        'connectionUrl',\r\n        'connectCallback',\r\n        'pingInterval',\r\n        'pingTimeout',\r\n        'lastPingReceived'\r\n    ]);\r\n\r\n}\r\n\r\n\r\nutil.inherits(Channel, EventEmitter);\r\n\r\n\r\n\r\n/**\r\n * Connects to the channel\r\n *\r\n * @param {Object} attributes Any attributes you want to associate with the client (ie. {name:\"FooBar\"}\r\n * @param {Function} callback The success callback handler\r\n * @param {Error} callback.arg1 Any error that may have occurred\r\n * @param {Client} callback.arg2 The connecting client\r\n *\r\n * @example\r\n * channel.connect({name:'Wheezy'},function(err, client){\r\n *   if(err) return console.error('something went wrong : ', error.code, error.message);\r\n *   console.info(client.attributes.name+', you are now connected');\r\n * });\r\n */\r\nChannel.prototype.connect = function(attributes, callback){\r\n\r\n    logger.debug('channel.connect',arguments);\r\n    if(this.isConnected) return console.warn('Channel is already connected.');\r\n\r\n    if(types.isFunction(attributes) && !callback){\r\n        callback = attributes;\r\n        attributes = {};\r\n    }else{\r\n        attributes = attributes || {};\r\n    }\r\n\r\n    // Validate arguments and connection state\r\n    if(!types.isObject(attributes))throw new TypeError('attributes must be a valid object');\r\n    if(callback && !types.isFunction(callback))throw new TypeError('callback must be a valid function');\r\n\r\n\r\n    // Store the callback\r\n    this.connectCallback = callback;\r\n\r\n    // TODO : Need to merge query string just in case the connection url already has a query (although it shouldn't)\r\n    var u = this.connectionUrl + '?' + util.queryString.stringify(attributes);\r\n\r\n    // Clean up any old connections\r\n    if(this.connection){\r\n        this.connection.onopen = null;\r\n        this.connection.onerror = null;\r\n        this.connection.onclose = null;\r\n        this.connection.onmessage = null;\r\n    }\r\n\r\n    // Connect the websocket and add our listeners\r\n    this.connection = new WebSocket(u);\r\n    this.connection.binaryType = \"arraybuffer\";\r\n    this.connection.onopen = this._onSocketOpen.bind(this);\r\n    this.connection.onerror = this._onSocketError.bind(this);\r\n    this.connection.onclose = this._onSocketClose.bind(this);\r\n    this.connection.onmessage = this._onSocketMessage.bind(this);\r\n};\r\n\r\n/**\r\n * Disconnects from the channel\r\n *\r\n * @param {Function} callback The success callback handler\r\n * @param {Error} callback.error Any error that may have occurred\r\n * @param {Client} callback.client The disconnecting client\r\n *\r\n * @example\r\n * channel.disconnect(function(err, client){\r\n *   if(err) return console.error('something went wrong : ', error.code, error.message);\r\n *   console.info(client.attributes.name+', you are now disconnected');\r\n * });\r\n */\r\nChannel.prototype.disconnect = function(callback){\r\n\r\n    logger.debug('channel.disconnect',arguments);\r\n    if(!this.isConnected) console.warn(\"channel is already disconnected\");\r\n\r\n    this.connection.close();\r\n    var self = this;\r\n    setTimeout(function(){\r\n        if(callback) callback(null, self);\r\n    },0);\r\n\r\n};\r\n\r\n/**\r\n * Publish an event message to the specified target or targets.\r\n * Targets can be in the for of a clients id, an array of client ids or one of the special message target strings (ie. \"all\" or \"host\"}\r\n *\r\n * @param {String} event The name of the event to emit\r\n * @param {any} [message] Any data associated with the event\r\n * @param {String|Array} [target='broadcast'] The target recipient(s) of the message\r\n * @param {Blob|ArrayBuffer} [payload] Any binary data to send with the message\r\n *\r\n * @example\r\n * channel.publish('myCustomEventName',{custom:'data'});\r\n */\r\nChannel.prototype.publish = function(event, message, target, payload){\r\n\r\n    logger.silly('channel.publish',arguments);\r\n    if(!this.isConnected) return console.warn('Channel is not connected.');\r\n\r\n    target = target || 'broadcast';\r\n    message = message || null;\r\n\r\n\r\n    if(!types.isString(event))throw new TypeError('event must be a valid string');\r\n    if(!(types.isString(target) || types.isArray(target))) throw new TypeError('targets must be a valid string or array');\r\n\r\n    this.invoke('ms.channel.emit',{\r\n        event   : event,\r\n        data    : message,\r\n        to      : target\r\n    }, null, true, payload);\r\n\r\n};\r\n\r\n\r\n\r\n\r\n/*\r\n Packs messages with payloads into binary message\r\n */\r\nChannel.packMessage = function(oMsg, payload){\r\n\r\n    logger.debug('channel.packMessage',arguments);\r\n\r\n    // convert js object to string\r\n    var msg = JSON.stringify(oMsg);\r\n\r\n    // get byte length of the string\r\n    var msgByteLength = new Blob([msg]).size;\r\n\r\n    // create 2 byte header which contains the length of the string (json) message\r\n    var hBuff = new ArrayBuffer(2);\r\n    var hView = new DataView(hBuff);\r\n    hView.setUint16(0,msgByteLength);\r\n\r\n    // binary packed message and payload\r\n    return new Blob([hBuff, msg, payload]);\r\n\r\n};\r\n\r\n/*\r\n Unpacks binary messages\r\n */\r\nChannel.unpackMessage = function(buffer){\r\n\r\n    logger.debug('channel.unpackMessage',arguments);\r\n\r\n    var json = '';\r\n    var view = new DataView(buffer);\r\n    var msgByteLen = view.getUint16(0);\r\n\r\n    for (var i = 0; i < msgByteLen; i++) {\r\n        json += String.fromCharCode(view.getUint8(i+2));\r\n    }\r\n\r\n    var payload = buffer.slice(2+msgByteLen);\r\n    var message = JSON.parse(json);\r\n\r\n    return {payload : payload, message : message};\r\n\r\n};\r\n\r\n\r\n\r\n/***\r\n * Invokes and RPC method on the server\r\n *\r\n * @protected\r\n *\r\n * @param {String} method The name of the method to invoke\r\n * @param {Object} params Named params to pass to the method\r\n * @param {Function} [callback] The success callback handler\r\n * @param {Error} callback.error Any error that may have occurred\r\n * @param {Boolean} callback.success\r\n * @param {Boolean} [isNotification=false] If true the message will have no id and no response handler will be stored\r\n * @param {ArrayBuffer|Blob} [payload] Any binary data to send along with the message\r\n *\r\n */\r\nChannel.prototype.invoke = function(method, params, callback, isNotification, payload){\r\n\r\n    logger.debug('channel.invoke',arguments);\r\n\r\n    if(!types.isString(method))throw new TypeError('method must be a valid string');\r\n\r\n    params = params || {};\r\n\r\n    var msg = {\r\n        method  : method,\r\n        params  : params\r\n    };\r\n\r\n    if(callback && !isNotification){\r\n        msg.id = Date.now();\r\n        this.resultHandlers[msg.id] = callback;\r\n    }\r\n\r\n    if(payload){\r\n        msg = Channel.packMessage(msg,payload);\r\n    }else{\r\n        msg = JSON.stringify(msg);\r\n    }\r\n\r\n    this.connection.send(msg);\r\n};\r\n\r\n/**\r\n * Fired when a channel makes a connection\r\n *\r\n * @event Channel#connect\r\n * @param {Client} client - Your client\r\n * @example\r\n * channel.on('connect',function(client){\r\n *  console.log('You are now connected');\r\n * });\r\n */\r\nChannel.prototype._onConnect = function(data) {\r\n\r\n    logger.silly('channel._onConnect');\r\n\r\n    this.connected = true;\r\n\r\n    // Store my id\r\n    this.clientId = data.id;\r\n\r\n    // Store the current connected client\r\n    data.clients.forEach(function(clientInfo){\r\n\r\n        // Create a client and add to our list\r\n        var client = new Client(clientInfo.id, clientInfo.attributes, clientInfo.isHost);\r\n        this.clients.push(client);\r\n\r\n    },this);\r\n\r\n    // call the connect callback if present and reset\r\n    if(this.connectCallback) {\r\n        logger.debug('channel.connect->callback',this.clients.me);\r\n        this.connectCallback(null, this.clients.me);\r\n        this.connectCallback = null;\r\n    }\r\n\r\n\r\n    logger.debug('channel.emit(\"connect\")',this.clients.me);\r\n    this.emit('connect',this.clients.me);\r\n\r\n};\r\n\r\n\r\n/**\r\n * Fired when a channel disconnects\r\n *\r\n * @event Channel#disconnect\r\n * @param {Client} client - Your client\r\n * @example\r\n * channel.on('disconnect',function(client){\r\n *  console.log('You are now disconnected');\r\n * });\r\n */\r\nChannel.prototype._onDisconnect = function(data) {\r\n    logger.silly('channel._onDisconnect');\r\n\r\n    if(this.connected){\r\n        var client = this.clients.me;\r\n        this.clients.clear();\r\n\r\n        logger.debug('channel.emit(\"disconnect\")',client);\r\n        this.emit('disconnect',client);\r\n    }\r\n    this.connected = false;\r\n\r\n\r\n};\r\n\r\n\r\n/**\r\n * Fired when a peer client channel makes a connection\r\n *\r\n * @event Channel#clientConnect\r\n * @param {Client} client - The client that connected\r\n * @example\r\n * channel.on('clientConnect',function(client){\r\n *  console.log(client.id + 'is now connected');\r\n * });\r\n */\r\nChannel.prototype._onClientConnect = function(data) {\r\n    logger.silly('channel._onClientConnect');\r\n\r\n    var client = new Client(data.id, data.attributes, data.isHost);\r\n    this.clients.push(client);\r\n\r\n    logger.debug('channel.emit(\"clientConnect\")',client);\r\n    this.emit('clientConnect',client);\r\n};\r\n\r\n/**\r\n * Fired when a peer client disconnects\r\n *\r\n * @event Channel#clientDisconnect\r\n * @param {Client} client - The client that connected\r\n * @example\r\n * channel.on('clientDisconnect',function(client){\r\n *  console.log(client.id + 'has disconnected');\r\n * });\r\n */\r\nChannel.prototype._onClientDisconnect = function(data) {\r\n    logger.silly('channel._onClientDisconnect');\r\n\r\n    var client = this.clients.getById(data.id);\r\n    if(client) this.clients.remove(client);\r\n    else {\r\n        logger.warn('client '+data.id+' could not be found, so it was not removed from the client list');\r\n        client = new Client(data.id, data.attributes, data.isHost);\r\n    }\r\n\r\n\r\n    logger.debug('channel.emit(\"clientDisconnect\")',client);\r\n    this.emit('clientDisconnect',client);\r\n\r\n};\r\n\r\n/***\r\n * Fired when the host has connected and is ready to accept messages\r\n * @deprecated since version 2.0.18 (please use the connect event)\r\n *\r\n * @event Channel#ready\r\n */\r\nChannel.prototype._onReady = function(data){\r\n\r\n    logger.debug('channel.emit(\"ready\")');\r\n    this.emit('ready');\r\n};\r\n\r\nChannel.prototype._onUserEvent = function(msg){\r\n\r\n    var client = this.clients.getById(msg.from);\r\n    var event = msg.event;\r\n    var data  = msg.data;\r\n    var payload = msg.payload;\r\n\r\n    logger.debug('channel.emit(\"'+event+'\")',data, client, payload);\r\n    this.emit(event, data, client, payload);\r\n};\r\n\r\nChannel.prototype._onSocketOpen = function() {\r\n    logger.silly('channel._onSocketOpen');\r\n};\r\n\r\nChannel.prototype._onSocketClose = function() {\r\n    logger.silly('channel._onSocketClose');\r\n    this._onDisconnect();\r\n};\r\n\r\nChannel.prototype._onSocketError = function(e) {\r\n    logger.silly('channel._onSocketError',e);\r\n    this.emit('error', new Error(\"WebSocket error\"));\r\n};\r\n\r\n\r\nChannel.prototype._onSocketMessage = function(msg){\r\n\r\n    logger.silly('channel._onSocketMessage',msg);\r\n\r\n    // Serialize the message\r\n    try{\r\n        if(typeof msg.data === \"string\"){\r\n            msg = JSON.parse(msg.data);\r\n        }else{\r\n            var unpacked = Channel.unpackMessage(msg.data);\r\n            msg = unpacked.message;\r\n            msg.payload = unpacked.payload;\r\n        }\r\n    } catch (e) {\r\n        logger.warn('unable to parse message', msg);\r\n        return;\r\n    }\r\n\r\n    // RPC Response?\r\n    if(msg.id && (msg.result || msg.error)){\r\n\r\n        if(!this.resultHandlers[msg.id]){\r\n            logger.warn('unable to find result handler for result message ', msg);\r\n            return;\r\n        }\r\n\r\n        this.resultHandlers[msg.id](msg.error,msg.result);\r\n\r\n    }\r\n    // Event?\r\n    else if (msg.event){\r\n\r\n        switch(msg.event){\r\n\r\n            case 'ms.channel.connect' :\r\n                this._onConnect(msg.data);\r\n                break;\r\n\r\n            case 'ms.channel.clientConnect' :\r\n                this._onClientConnect(msg.data);\r\n                break;\r\n\r\n            case 'ms.channel.clientDisconnect' :\r\n                this._onClientDisconnect(msg.data);\r\n                break;\r\n\r\n            case 'ms.channel.ready' :\r\n                this._onReady(msg.data);\r\n                break;\r\n\r\n            default :\r\n                this._onUserEvent(msg);\r\n                break;\r\n        }\r\n    }\r\n    // Unrecognized\r\n    else{\r\n        logger.warn('unrecognized message type', msg);\r\n    }\r\n\r\n};\r\n\r\nChannel.prototype.startHealthCheck = function(){\r\n\r\n    // stop any previous health checking\r\n    this.stopHealthCheck();\r\n\r\n    if(this.pingTimeout > 0){\r\n\r\n        var lastReceivedPing = null;\r\n\r\n        this.on(EVENT_HEALTH_CHECK, function(sent){\r\n            lastReceivedPing = Date.now();\r\n            logger.debug('ping trip : ',lastReceivedPing - sent);\r\n            logger.debug('updated last ping time : ',lastReceivedPing);\r\n        });\r\n\r\n        var checkAndPing = function(){\r\n\r\n            var now = Date.now();\r\n            if(!lastReceivedPing) lastReceivedPing = now;\r\n\r\n            if(now - lastReceivedPing < this.pingTimeout){\r\n                logger.debug('sending ping');\r\n                this.publish(EVENT_HEALTH_CHECK, now, this.clients.me.id);\r\n            }else{\r\n                logger.debug('ping timed, out closing connection');\r\n                this.stopHealthCheck();\r\n                if(this.connection){\r\n                    this.connection.close();\r\n                    // forcing disconnect\r\n                    this._onDisconnect();\r\n                }\r\n            }\r\n        }.bind(this);\r\n\r\n        // start the timer\r\n        this.pingInterval = setInterval(checkAndPing,this.pingTimeout);\r\n    }\r\n\r\n\r\n\r\n};\r\n\r\nChannel.prototype.stopHealthCheck = function(){\r\n    clearInterval(this.pingInterval);\r\n    this.removeAllListeners(EVENT_HEALTH_CHECK);\r\n};\r\n\r\n\r\nmodule.exports = Channel;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Channel.js\n ** module id = 7\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar levels = ['error','warn','info','verbose','debug','silly'];\r\n\r\nvar logger = {\r\n\r\n    level : 'disabled',\r\n\r\n    log : function(level /* ,....args*/){\r\n        if(logger.level !== 'disabled' && (levels.indexOf(level) <= levels.indexOf(logger.level))){\r\n            var args = Array.prototype.slice.call(arguments,1);\r\n            args.unshift('[MSF:'+level.toUpperCase()+']');\r\n            if(console[level]){\r\n                console[level].apply(console,args);\r\n            }else{\r\n                console.log.apply(console,args);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n};\r\n\r\nfunction createLevel(level){\r\n    return function(/*args*/){\r\n        var args = Array.prototype.slice.call(arguments);\r\n        args.unshift(level);\r\n        logger.log.apply(logger,args);\r\n    };\r\n}\r\n\r\n// Create logger methods based on levels\r\nfor(var i=0; i<levels.length; i++){\r\n    var level = levels[i];\r\n    logger[level] = createLevel(level);\r\n}\r\n\r\nmodule.exports = logger;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/logger.js\n ** module id = 8\n ** module chunks = 0\n **/","\"use strict\";\r\nvar queryString = require('./querystring');\r\n\r\nvar url = {\r\n\r\n    isValid : function(u){\r\n\r\n        var pattern = /^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;\r\n        return u.match(pattern) ? true : false;\r\n    },\r\n\r\n    parse : function(u){\r\n\r\n        var oUrl = {};\r\n        var parser = document.createElement('a');\r\n        parser.href = u; // \"http://example.com:3000/pathname/?search=test#hash\";\r\n\r\n        oUrl.href = parser.href; // => \"http://ip:port/path/page?query=string#hash\"\r\n        oUrl.protocol = parser.protocol; // => \"http:\"\r\n        oUrl.hostname = parser.hostname; // => \"example.com\"\r\n        oUrl.port = parser.port;     // => \"3000\"\r\n        oUrl.pathname = parser.pathname; // => \"/pathname/\"\r\n        oUrl.search = parser.search;   // => \"?search=test\"\r\n        oUrl.hash = parser.hash;     // => \"#hash\"\r\n        oUrl.host = parser.host;     // => \"example.com:3000\"\r\n        oUrl.queryString = queryString.parse(parser.search);\r\n\r\n        return oUrl;\r\n    }\r\n\r\n\r\n};\r\n\r\nmodule.exports = url;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/url.js\n ** module id = 9\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nif (typeof Object.create === 'function') {\r\n    // implementation from standard node.js 'util' module\r\n    module.exports = function inherits(ctor, superCtor) {\r\n        ctor.super_ = superCtor;\r\n        ctor.prototype = Object.create(superCtor.prototype, {\r\n            constructor: {\r\n                value: ctor,\r\n                enumerable: false,\r\n                writable: true,\r\n                configurable: true\r\n            }\r\n        });\r\n    };\r\n} else {\r\n    // old school shim for old browsers\r\n    module.exports = function inherits(ctor, superCtor) {\r\n        ctor.super_ = superCtor;\r\n        var TempCtor = function () {};\r\n        TempCtor.prototype = superCtor.prototype;\r\n        ctor.prototype = new TempCtor();\r\n        ctor.prototype.constructor = ctor;\r\n    };\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/inherits.js\n ** module id = 10\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nfunction createDescriptor(e,c,w,v){\r\n    return {\r\n        enumerable : e,\r\n        configurable : c,\r\n        writable : w,\r\n        value : v\r\n    };\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    readOnly : function(obj, key){\r\n\r\n        if(Array.isArray(key)){\r\n            key.forEach(function(k){\r\n                Object.defineProperty(obj, k, createDescriptor(true,true,false,obj[k]));\r\n            });\r\n        }else{\r\n            Object.defineProperty(obj, key, createDescriptor(true,true,false,obj[key]));\r\n        }\r\n\r\n    },\r\n\r\n    private : function(obj, key){\r\n\r\n        if(Array.isArray(key)){\r\n            key.forEach(function(k){ Object.defineProperty(obj, k, createDescriptor(false,true,true,obj[k])); });\r\n        }else{\r\n            Object.defineProperty(obj, key, createDescriptor(false,true,true,obj[key]));\r\n        }\r\n    }\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/props.js\n ** module id = 11\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nmodule.exports = {\r\n\r\n    isString : function(obj){\r\n        return typeof obj === 'string';\r\n    },\r\n\r\n    isNull : function(obj){\r\n        return obj === null;\r\n    },\r\n\r\n    isBoolean : function(obj){\r\n        return typeof obj === 'boolean';\r\n    },\r\n\r\n    isNumber : function(obj){\r\n        return typeof obj === 'number';\r\n    },\r\n\r\n    isObject : function(obj){\r\n        return obj === Object(obj);\r\n    },\r\n\r\n    isArray : function(obj){\r\n        return obj.constructor === Array;\r\n    },\r\n\r\n    isFunction : function(obj){\r\n        return typeof obj === 'function';\r\n    },\r\n\r\n    isUndefined : function(obj){\r\n        return typeof obj === 'undefined';\r\n    }\r\n\r\n\r\n\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/types.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\r\n\r\n/*\r\n    Derived work from Sidre Sorhus (https://github.com/sindresorhus/query-string)\r\n */\r\n\r\n/*!\r\n query-string\r\n Parse and stringify URL query strings\r\n https://github.com/sindresorhus/query-string\r\n by Sindre Sorhus\r\n MIT License\r\n */\r\n\r\nvar queryString = {};\r\n\r\nqueryString.parse = function (str) {\r\n    if (typeof str !== 'string') {\r\n        return {};\r\n    }\r\n\r\n    str = str.trim().replace(/^(\\?|#)/, '');\r\n\r\n    if (!str) {\r\n        return {};\r\n    }\r\n\r\n    return str.trim().split('&').reduce(function (ret, param) {\r\n        var parts = param.replace(/\\+/g, ' ').split('=');\r\n        var key = parts[0];\r\n        var val = parts[1];\r\n\r\n        key = decodeURIComponent(key);\r\n        // missing `=` should be `null`:\r\n        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\r\n        val = val === undefined ? null : decodeURIComponent(val);\r\n\r\n        if (!ret.hasOwnProperty(key)) {\r\n            ret[key] = val;\r\n        } else if (Array.isArray(ret[key])) {\r\n            ret[key].push(val);\r\n        } else {\r\n            ret[key] = [ret[key], val];\r\n        }\r\n\r\n        return ret;\r\n    }, {});\r\n};\r\n\r\nqueryString.stringify = function (obj) {\r\n    return obj ? Object.keys(obj).map(function (key) {\r\n        var val = obj[key];\r\n\r\n        if (Array.isArray(val)) {\r\n            return val.map(function (val2) {\r\n                return encodeURIComponent(key) + '=' + encodeURIComponent(val2);\r\n            }).join('&');\r\n        }\r\n\r\n        return encodeURIComponent(key) + '=' + encodeURIComponent(val);\r\n    }).join('&') : '';\r\n};\r\n\r\nmodule.exports = queryString;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/querystring.js\n ** module id = 13\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar types = util.types;\r\n\r\n\r\n/**\r\n * A representation of an individual device or user connected to a channel.\r\n * Clients can have user defined attributes that are readable by all other clients.\r\n * @class Client\r\n *\r\n * @hide-constructor\r\n *\r\n */\r\nfunction Client(id, attributes, isHost, connectTime){\r\n\r\n    if(!types.isString(id)) throw new TypeError('id must be a valid string');\r\n    if(attributes && !types.isObject(attributes)) throw new TypeError('attributes must be a valid object');\r\n\r\n    /**\r\n     * The id of the client\r\n     *\r\n     * @name id\r\n     * @memberOf Client.prototype\r\n     * @type {String}\r\n     * @readonly\r\n     *\r\n     */\r\n    this.id = id;\r\n\r\n    /**\r\n     * A map of attributes passed by the client when connecting\r\n     *\r\n     * @name attributes\r\n     * @memberOf Client.prototype\r\n     * @type {Object}\r\n     * @readonly\r\n     *\r\n     */\r\n    this.attributes = attributes || {};\r\n\r\n    /**\r\n     * Flag for determining if the client is the host\r\n     *\r\n     * @name isHost\r\n     * @memberOf Client.prototype\r\n     * @type {Boolean}\r\n     * @readonly\r\n     *\r\n     */\r\n    this.isHost = isHost;\r\n\r\n    /**\r\n     * The time which the client connected in epoch milliseconds\r\n     *\r\n     * @name connectTime\r\n     * @memberOf Client.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     *\r\n     */\r\n    this.connectTime = connectTime || Date.now();\r\n\r\n    Object.freeze(this.attributes);\r\n    Object.freeze(this);\r\n\r\n}\r\n\r\nmodule.exports = Client;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Client.js\n ** module id = 14\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar types = util.types;\r\n\r\n/**\r\n * A list of {@link Client|clients} accessible through {@link Channel#clients|channel.clients}.\r\n * This list is managed by the channel and automatically adds and removes clients as they connect and disconnect\r\n * @class ClientList\r\n * @extends Array\r\n * @hide-constructor\r\n */\r\n\r\nfunction ClientList(channel){\r\n\r\n    if(!types.isObject(channel))throw new TypeError('channel must be of type Channel');\r\n\r\n    this.channel = channel;\r\n\r\n    ClientList.super_.call(this);\r\n\r\n}\r\n\r\nutil.inherits(ClientList, Array);\r\n\r\n/**\r\n * A reference to your client\r\n *\r\n * @member {Client} ClientList#me\r\n * @readonly\r\n */\r\nObject.defineProperty(ClientList.prototype, 'me', {\r\n    get : function(){\r\n        return this.getById(this.channel.clientId);\r\n    }\r\n});\r\n\r\n/***\r\n * Clears the list\r\n * @protected\r\n */\r\nClientList.prototype.clear = function(){\r\n    this.length = 0;\r\n};\r\n\r\n/***\r\n * Removes an client from the list\r\n * @protected\r\n */\r\nClientList.prototype.remove = function(item){\r\n    var i = this.indexOf(item);\r\n    if(i !== -1) {\r\n        this.splice(i, 1);\r\n        return item;\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n/**\r\n * Returns a client by id\r\n *\r\n * @param {String} id The client\r\n * @return {Client}\r\n *\r\n */\r\nClientList.prototype.getById = function(id){\r\n\r\n    if(!types.isString(id) && !types.isNumber(id)) throw new TypeError('id must be a valid string or number');\r\n    for(var i=0; i<this.length; i++){\r\n        if(this[i].id === id) return this[i];\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\nmodule.exports = ClientList;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/ClientList.js\n ** module id = 15\n ** module chunks = 0\n **/"],"sourceRoot":""}